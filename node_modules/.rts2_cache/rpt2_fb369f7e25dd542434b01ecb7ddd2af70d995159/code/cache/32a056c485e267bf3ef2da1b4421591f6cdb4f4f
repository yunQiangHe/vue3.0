{"code":"import { compile } from '@vue/compiler-dom';\r\nimport { compilerOptions, initOptions } from './options';\r\nimport { watch } from '@vue/runtime-dom';\r\nwindow.init = () => {\r\n    const monaco = window.monaco;\r\n    const persistedState = JSON.parse(decodeURIComponent(window.location.hash.slice(1)) || `{}`);\r\n    Object.assign(compilerOptions, persistedState.options);\r\n    let lastSuccessfulCode = `/* See console for error */`;\r\n    let lastSuccessfulMap = undefined;\r\n    function compileCode(source) {\r\n        console.clear();\r\n        try {\r\n            const { code, ast, map } = compile(source, {\r\n                filename: 'template.vue',\r\n                ...compilerOptions,\r\n                sourceMap: true,\r\n                onError: displayError\r\n            });\r\n            monaco.editor.setModelMarkers(editor.getModel(), `@vue/compiler-dom`, []);\r\n            console.log(`AST: `, ast);\r\n            lastSuccessfulCode = code + `\\n\\n// Check the console for the AST`;\r\n            lastSuccessfulMap = new window._deps['source-map'].SourceMapConsumer(map);\r\n            lastSuccessfulMap.computeColumnSpans();\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n        return lastSuccessfulCode;\r\n    }\r\n    function displayError(err) {\r\n        const loc = err.loc;\r\n        if (loc) {\r\n            monaco.editor.setModelMarkers(editor.getModel(), `@vue/compiler-dom`, [\r\n                {\r\n                    severity: monaco.MarkerSeverity.Error,\r\n                    startLineNumber: loc.start.line,\r\n                    startColumn: loc.start.column,\r\n                    endLineNumber: loc.end.line,\r\n                    endColumn: loc.end.column,\r\n                    message: `Vue template compilation error: ${err.message}`,\r\n                    code: String(err.code)\r\n                }\r\n            ]);\r\n        }\r\n        throw err;\r\n    }\r\n    function reCompile() {\r\n        const src = editor.getValue();\r\n        // every time we re-compile, persist current state to URL\r\n        window.location.hash = encodeURIComponent(JSON.stringify({\r\n            src,\r\n            options: compilerOptions\r\n        }));\r\n        const res = compileCode(src);\r\n        if (res) {\r\n            output.setValue(res);\r\n        }\r\n    }\r\n    const sharedEditorOptions = {\r\n        theme: 'vs-dark',\r\n        fontSize: 14,\r\n        wordWrap: 'on',\r\n        scrollBeyondLastLine: false,\r\n        renderWhitespace: 'selection',\r\n        contextmenu: false,\r\n        minimap: {\r\n            enabled: false\r\n        }\r\n    };\r\n    const editor = monaco.editor.create(document.getElementById('source'), {\r\n        value: persistedState.src || `<div>Hello World!</div>`,\r\n        language: 'html',\r\n        ...sharedEditorOptions\r\n    });\r\n    editor.getModel().updateOptions({\r\n        tabSize: 2\r\n    });\r\n    const output = monaco.editor.create(document.getElementById('output'), {\r\n        value: '',\r\n        language: 'javascript',\r\n        readOnly: true,\r\n        ...sharedEditorOptions\r\n    });\r\n    output.getModel().updateOptions({\r\n        tabSize: 2\r\n    });\r\n    // handle resize\r\n    window.addEventListener('resize', () => {\r\n        editor.layout();\r\n        output.layout();\r\n    });\r\n    // update compile output when input changes\r\n    editor.onDidChangeModelContent(debounce(reCompile));\r\n    // highlight output code\r\n    let prevOutputDecos = [];\r\n    function clearOutputDecos() {\r\n        prevOutputDecos = output.deltaDecorations(prevOutputDecos, []);\r\n    }\r\n    editor.onDidChangeCursorPosition(debounce(e => {\r\n        clearEditorDecos();\r\n        if (lastSuccessfulMap) {\r\n            const pos = lastSuccessfulMap.generatedPositionFor({\r\n                source: 'template.vue',\r\n                line: e.position.lineNumber,\r\n                column: e.position.column - 1\r\n            });\r\n            if (pos.line != null && pos.column != null) {\r\n                prevOutputDecos = output.deltaDecorations(prevOutputDecos, [\r\n                    {\r\n                        range: new monaco.Range(pos.line, pos.column + 1, pos.line, pos.lastColumn ? pos.lastColumn + 2 : pos.column + 2),\r\n                        options: {\r\n                            inlineClassName: `highlight`\r\n                        }\r\n                    }\r\n                ]);\r\n                output.revealPositionInCenter({\r\n                    lineNumber: pos.line,\r\n                    column: pos.column + 1\r\n                });\r\n            }\r\n            else {\r\n                clearOutputDecos();\r\n            }\r\n        }\r\n    }, 100));\r\n    let previousEditorDecos = [];\r\n    function clearEditorDecos() {\r\n        previousEditorDecos = editor.deltaDecorations(previousEditorDecos, []);\r\n    }\r\n    output.onDidChangeCursorPosition(debounce(e => {\r\n        clearOutputDecos();\r\n        if (lastSuccessfulMap) {\r\n            const pos = lastSuccessfulMap.originalPositionFor({\r\n                line: e.position.lineNumber,\r\n                column: e.position.column - 1\r\n            });\r\n            if (pos.line != null &&\r\n                pos.column != null &&\r\n                !(pos.line === 1 && pos.column === 0)) {\r\n                const translatedPos = {\r\n                    column: pos.column + 1,\r\n                    lineNumber: pos.line\r\n                };\r\n                previousEditorDecos = editor.deltaDecorations(previousEditorDecos, [\r\n                    {\r\n                        range: new monaco.Range(pos.line, pos.column + 1, pos.line, pos.column + 1),\r\n                        options: {\r\n                            isWholeLine: true,\r\n                            className: `highlight`\r\n                        }\r\n                    }\r\n                ]);\r\n                editor.revealPositionInCenter(translatedPos);\r\n            }\r\n            else {\r\n                clearEditorDecos();\r\n            }\r\n        }\r\n    }, 100));\r\n    initOptions();\r\n    watch(reCompile);\r\n};\r\nfunction debounce(fn, delay = 300) {\r\n    let prevTimer = null;\r\n    return ((...args) => {\r\n        if (prevTimer) {\r\n            clearTimeout(prevTimer);\r\n        }\r\n        prevTimer = setTimeout(() => {\r\n            fn(...args);\r\n            prevTimer = null;\r\n        }, delay);\r\n    });\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/node_modules/monaco-editor/esm/vs/editor/editor.api.d.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-dom/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/template-explorer/src/options.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-dom/src/index.ts","/Users/apple/Desktop/vue3/vue-next/node_modules/source-map/source-map.d.ts"]}
