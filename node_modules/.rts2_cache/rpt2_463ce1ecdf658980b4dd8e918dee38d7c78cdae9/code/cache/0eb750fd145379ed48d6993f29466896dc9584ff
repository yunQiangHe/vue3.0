{"code":"import { isArray, isFunction, isString, isObject, EMPTY_ARR, extend } from '@vue/shared';\r\nimport { SetupProxySymbol } from './component';\r\nimport { isReactive } from '@vue/reactivity';\r\nexport const Fragment = __DEV__ ? Symbol('Fragment') : Symbol();\r\nexport const Text = __DEV__ ? Symbol('Text') : Symbol();\r\nexport const Comment = __DEV__ ? Symbol('Empty') : Symbol();\r\nexport const Portal = __DEV__ ? Symbol('Portal') : Symbol();\r\nexport const Suspense = __DEV__ ? Symbol('Suspense') : Symbol();\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\n// Open a block.\r\n// This must be called before `createBlock`. It cannot be part of `createBlock`\r\n// because the children of the block are evaluated before `createBlock` itself\r\n// is called. The generated code typically looks like this:\r\n//\r\n//   function render() {\r\n//     return (openBlock(),createBlock('div', null, [...]))\r\n//   }\r\n//\r\n// disableTracking is true when creating a fragment block, since a fragment\r\n// always diffs its children.\r\nexport function openBlock(disableTracking) {\r\n    blockStack.push(disableTracking ? null : []);\r\n}\r\nlet shouldTrack = true;\r\n// Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n// A block root keeps track of dynamic nodes within the block in the\r\n// `dynamicChildren` array.\r\nexport function createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    // avoid a block with optFlag tracking itself\r\n    shouldTrack = false;\r\n    const vnode = createVNode(type, props, children, patchFlag, dynamicProps);\r\n    shouldTrack = true;\r\n    const trackedNodes = blockStack.pop();\r\n    vnode.dynamicChildren =\r\n        trackedNodes && trackedNodes.length ? trackedNodes : EMPTY_ARR;\r\n    // a block is always going to be patched\r\n    trackDynamicNode(vnode);\r\n    return vnode;\r\n}\r\nexport function isVNode(value) {\r\n    return value ? value._isVNode === true : false;\r\n}\r\nexport function createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null) {\r\n    // class & style normalization.\r\n    if (props !== null) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isReactive(props) || SetupProxySymbol in props) {\r\n            props = extend({}, props);\r\n        }\r\n        // class normalization only needed if the vnode isn't generated by\r\n        // compiler-optimized code\r\n        if (props.class != null && !(patchFlag & 2 /* CLASS */)) {\r\n            props.class = normalizeClass(props.class);\r\n        }\r\n        let { style } = props;\r\n        if (style != null) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isReactive(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        : isObject(type)\r\n            ? 4 /* STATEFUL_COMPONENT */\r\n            : isFunction(type)\r\n                ? 2 /* FUNCTIONAL_COMPONENT */\r\n                : 0;\r\n    const vnode = {\r\n        _isVNode: true,\r\n        type,\r\n        props,\r\n        key: (props && props.key) || null,\r\n        ref: (props && props.ref) || null,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    normalizeChildren(vnode, children);\r\n    // presence of a patch flag indicates this node needs patching on updates.\r\n    // component nodes also should always be patched, because even if the\r\n    // component doesn't need to update, it needs to persist the instance on to\r\n    // the next vnode so that it can be properly unmounted later.\r\n    if (shouldTrack &&\r\n        (patchFlag ||\r\n            shapeFlag & 4 /* STATEFUL_COMPONENT */ ||\r\n            shapeFlag & 2 /* FUNCTIONAL_COMPONENT */)) {\r\n        trackDynamicNode(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction trackDynamicNode(vnode) {\r\n    const currentBlockDynamicNodes = blockStack[blockStack.length - 1];\r\n    if (currentBlockDynamicNodes != null) {\r\n        currentBlockDynamicNodes.push(vnode);\r\n    }\r\n}\r\nexport function cloneVNode(vnode) {\r\n    return {\r\n        _isVNode: true,\r\n        type: vnode.type,\r\n        props: vnode.props,\r\n        key: vnode.key,\r\n        ref: vnode.ref,\r\n        children: vnode.children,\r\n        target: vnode.target,\r\n        shapeFlag: vnode.shapeFlag,\r\n        patchFlag: vnode.patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        // these should be set to null since they should only be present on\r\n        // mounted VNodes. If they are somehow not null, this means we have\r\n        // encountered an already-mounted vnode being used again.\r\n        component: null,\r\n        suspense: null,\r\n        el: null,\r\n        anchor: null\r\n    };\r\n}\r\nexport function normalizeVNode(child) {\r\n    if (child == null) {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (isArray(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // primitive types\r\n        return createVNode(Text, null, child + '');\r\n    }\r\n}\r\nexport function normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = isString(children) ? children : children + '';\r\n        type = 8 /* TEXT_CHILDREN */;\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeStyle(value[i]);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nexport function normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            res += normalizeClass(value[i]) + ' ';\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\r\nconst handlersRE = /^on|^vnode/;\r\nexport function mergeProps(...args) {\r\n    const ret = {};\r\n    extend(ret, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                ret.class = normalizeClass([ret.class, toMerge.class]);\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (handlersRE.test(key)) {\r\n                // on*, vnode*\r\n                const existing = ret[key];\r\n                ret[key] = existing\r\n                    ? [].concat(existing, toMerge[key])\r\n                    : toMerge[key];\r\n            }\r\n            else {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/component.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentSlots.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/shapeFlags.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiApp.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/suspense.ts"]}
