{"code":"import { createCompilerError, defaultOnError } from './errors';\r\nimport { assert, advancePositionWithMutation, advancePositionWithClone } from './utils';\r\nexport const defaultParserOptions = {\r\n    delimiters: [`{{`, `}}`],\r\n    ignoreSpaces: true,\r\n    getNamespace: () => 0 /* HTML */,\r\n    getTextMode: () => 0 /* DATA */,\r\n    isVoidTag: () => false,\r\n    namedCharacterReferences: {\r\n        'gt;': '>',\r\n        'lt;': '<',\r\n        'amp;': '&',\r\n        'apos;': \"'\",\r\n        'quot;': '\"'\r\n    },\r\n    onError: defaultOnError\r\n};\r\nexport function parse(content, options = {}) {\r\n    const context = createParserContext(content, options);\r\n    const start = getCursor(context);\r\n    return {\r\n        type: 0 /* ROOT */,\r\n        children: parseChildren(context, 0 /* DATA */, []),\r\n        helpers: [],\r\n        components: [],\r\n        directives: [],\r\n        hoists: [],\r\n        codegenNode: undefined,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction createParserContext(content, options) {\r\n    return {\r\n        options: {\r\n            ...defaultParserOptions,\r\n            ...options\r\n        },\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        originalSource: content,\r\n        source: content,\r\n        maxCRNameLength: Object.keys(options.namedCharacterReferences ||\r\n            defaultParserOptions.namedCharacterReferences).reduce((max, name) => Math.max(max, name.length), 0)\r\n    };\r\n}\r\nfunction parseChildren(context, mode, ancestors) {\r\n    const parent = last(ancestors);\r\n    const ns = parent ? parent.ns : 0 /* HTML */;\r\n    const nodes = [];\r\n    while (!isEnd(context, mode, ancestors)) {\r\n        __DEV__ && assert(context.source.length > 0);\r\n        const s = context.source;\r\n        let node = undefined;\r\n        if (startsWith(s, context.options.delimiters[0])) {\r\n            // '{{'\r\n            node = parseInterpolation(context, mode);\r\n        }\r\n        else if (mode === 0 /* DATA */ && s[0] === '<') {\r\n            // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\r\n            if (s.length === 1) {\r\n                emitError(context, 8 /* EOF_BEFORE_TAG_NAME */, 1);\r\n            }\r\n            else if (s[1] === '!') {\r\n                // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\r\n                if (startsWith(s, '<!--')) {\r\n                    node = parseComment(context);\r\n                }\r\n                else if (startsWith(s, '<!DOCTYPE')) {\r\n                    // Ignore DOCTYPE by a limitation.\r\n                    node = parseBogusComment(context);\r\n                }\r\n                else if (startsWith(s, '<![CDATA[')) {\r\n                    if (ns !== 0 /* HTML */) {\r\n                        node = parseCDATA(context, ancestors);\r\n                    }\r\n                    else {\r\n                        emitError(context, 2 /* CDATA_IN_HTML_CONTENT */);\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                }\r\n                else {\r\n                    emitError(context, 14 /* INCORRECTLY_OPENED_COMMENT */);\r\n                    node = parseBogusComment(context);\r\n                }\r\n            }\r\n            else if (s[1] === '/') {\r\n                // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\r\n                if (s.length === 2) {\r\n                    emitError(context, 8 /* EOF_BEFORE_TAG_NAME */, 2);\r\n                }\r\n                else if (s[2] === '>') {\r\n                    emitError(context, 17 /* MISSING_END_TAG_NAME */, 2);\r\n                    advanceBy(context, 3);\r\n                    continue;\r\n                }\r\n                else if (/[a-z]/i.test(s[2])) {\r\n                    emitError(context, 31 /* X_INVALID_END_TAG */);\r\n                    parseTag(context, 1 /* End */, parent);\r\n                    continue;\r\n                }\r\n                else {\r\n                    emitError(context, 15 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);\r\n                    node = parseBogusComment(context);\r\n                }\r\n            }\r\n            else if (/[a-z]/i.test(s[1])) {\r\n                node = parseElement(context, ancestors);\r\n            }\r\n            else if (s[1] === '?') {\r\n                emitError(context, 28 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);\r\n                node = parseBogusComment(context);\r\n            }\r\n            else {\r\n                emitError(context, 15 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);\r\n            }\r\n        }\r\n        if (!node) {\r\n            node = parseText(context, mode);\r\n        }\r\n        if (Array.isArray(node)) {\r\n            for (let i = 0; i < node.length; i++) {\r\n                pushNode(context, nodes, node[i]);\r\n            }\r\n        }\r\n        else {\r\n            pushNode(context, nodes, node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\nfunction pushNode(context, nodes, node) {\r\n    // ignore comments in production\r\n    /* istanbul ignore next */\r\n    if (!__DEV__ && node.type === 3 /* COMMENT */) {\r\n        return;\r\n    }\r\n    if (context.options.ignoreSpaces &&\r\n        node.type === 2 /* TEXT */ &&\r\n        node.isEmpty) {\r\n        return;\r\n    }\r\n    // Merge if both this and the previous node are text and those are consecutive.\r\n    // This happens on \"a < b\" or something like.\r\n    const prev = last(nodes);\r\n    if (prev &&\r\n        prev.type === 2 /* TEXT */ &&\r\n        node.type === 2 /* TEXT */ &&\r\n        prev.loc.end.offset === node.loc.start.offset) {\r\n        prev.content += node.content;\r\n        prev.isEmpty = prev.content.trim().length === 0;\r\n        prev.loc.end = node.loc.end;\r\n        prev.loc.source += node.loc.source;\r\n    }\r\n    else {\r\n        nodes.push(node);\r\n    }\r\n}\r\nfunction parseCDATA(context, ancestors) {\r\n    __DEV__ &&\r\n        assert(last(ancestors) == null || last(ancestors).ns !== 0 /* HTML */);\r\n    __DEV__ && assert(startsWith(context.source, '<![CDATA['));\r\n    advanceBy(context, 9);\r\n    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);\r\n    if (context.source.length === 0) {\r\n        emitError(context, 9 /* EOF_IN_CDATA */);\r\n    }\r\n    else {\r\n        __DEV__ && assert(startsWith(context.source, ']]>'));\r\n        advanceBy(context, 3);\r\n    }\r\n    return nodes;\r\n}\r\nfunction parseComment(context) {\r\n    __DEV__ && assert(startsWith(context.source, '<!--'));\r\n    const start = getCursor(context);\r\n    let content;\r\n    // Regular comment.\r\n    const match = /--(\\!)?>/.exec(context.source);\r\n    if (!match) {\r\n        content = context.source.slice(4);\r\n        advanceBy(context, context.source.length);\r\n        emitError(context, 10 /* EOF_IN_COMMENT */);\r\n    }\r\n    else {\r\n        if (match.index <= 3) {\r\n            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);\r\n        }\r\n        if (match[1]) {\r\n            emitError(context, 13 /* INCORRECTLY_CLOSED_COMMENT */);\r\n        }\r\n        content = context.source.slice(4, match.index);\r\n        // Advancing with reporting nested comments.\r\n        const s = context.source.slice(0, match.index);\r\n        let prevIndex = 1, nestedIndex = 0;\r\n        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\r\n            advanceBy(context, nestedIndex - prevIndex + 1);\r\n            if (nestedIndex + 4 < s.length) {\r\n                emitError(context, 20 /* NESTED_COMMENT */);\r\n            }\r\n            prevIndex = nestedIndex + 1;\r\n        }\r\n        advanceBy(context, match.index + match[0].length - prevIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseBogusComment(context) {\r\n    __DEV__ && assert(/^<(?:[\\!\\?]|\\/[^a-z>])/i.test(context.source));\r\n    const start = getCursor(context);\r\n    const contentStart = context.source[1] === '?' ? 1 : 2;\r\n    let content;\r\n    const closeIndex = context.source.indexOf('>');\r\n    if (closeIndex === -1) {\r\n        content = context.source.slice(contentStart);\r\n        advanceBy(context, context.source.length);\r\n    }\r\n    else {\r\n        content = context.source.slice(contentStart, closeIndex);\r\n        advanceBy(context, closeIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseElement(context, ancestors) {\r\n    __DEV__ && assert(/^<[a-z]/i.test(context.source));\r\n    // Start tag.\r\n    const parent = last(ancestors);\r\n    const element = parseTag(context, 0 /* Start */, parent);\r\n    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\r\n        return element;\r\n    }\r\n    // Children.\r\n    ancestors.push(element);\r\n    const mode = context.options.getTextMode(element.tag, element.ns);\r\n    const children = parseChildren(context, mode, ancestors);\r\n    ancestors.pop();\r\n    element.children = children;\r\n    // End tag.\r\n    if (startsWithEndTagOpen(context.source, element.tag)) {\r\n        parseTag(context, 1 /* End */, parent);\r\n    }\r\n    else {\r\n        emitError(context, 32 /* X_MISSING_END_TAG */);\r\n        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\r\n            const first = children[0];\r\n            if (first && startsWith(first.loc.source, '<!--')) {\r\n                emitError(context, 11 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);\r\n            }\r\n        }\r\n    }\r\n    element.loc = getSelection(context, element.loc.start);\r\n    return element;\r\n}\r\n/**\r\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\r\n */\r\nfunction parseTag(context, type, parent) {\r\n    __DEV__ && assert(/^<\\/?[a-z]/i.test(context.source));\r\n    __DEV__ &&\r\n        assert(type === (startsWith(context.source, '</') ? 1 /* End */ : 0 /* Start */));\r\n    // Tag open.\r\n    const start = getCursor(context);\r\n    const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\r\n    const tag = match[1];\r\n    const props = [];\r\n    const ns = context.options.getNamespace(tag, parent);\r\n    let tagType = 0 /* ELEMENT */;\r\n    if (tag === 'slot')\r\n        tagType = 2 /* SLOT */;\r\n    else if (tag === 'template')\r\n        tagType = 3 /* TEMPLATE */;\r\n    else if (/[A-Z-]/.test(tag))\r\n        tagType = 1 /* COMPONENT */;\r\n    advanceBy(context, match[0].length);\r\n    advanceSpaces(context);\r\n    // Attributes.\r\n    const attributeNames = new Set();\r\n    while (context.source.length > 0 &&\r\n        !startsWith(context.source, '>') &&\r\n        !startsWith(context.source, '/>')) {\r\n        if (startsWith(context.source, '/')) {\r\n            emitError(context, 29 /* UNEXPECTED_SOLIDUS_IN_TAG */);\r\n            advanceBy(context, 1);\r\n            advanceSpaces(context);\r\n            continue;\r\n        }\r\n        if (type === 1 /* End */) {\r\n            emitError(context, 6 /* END_TAG_WITH_ATTRIBUTES */);\r\n        }\r\n        const attr = parseAttribute(context, attributeNames);\r\n        if (type === 0 /* Start */) {\r\n            props.push(attr);\r\n        }\r\n        if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\r\n            emitError(context, 19 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);\r\n        }\r\n        advanceSpaces(context);\r\n    }\r\n    // Tag close.\r\n    let isSelfClosing = false;\r\n    if (context.source.length === 0) {\r\n        emitError(context, 12 /* EOF_IN_TAG */);\r\n    }\r\n    else {\r\n        isSelfClosing = startsWith(context.source, '/>');\r\n        if (type === 1 /* End */ && isSelfClosing) {\r\n            emitError(context, 7 /* END_TAG_WITH_TRAILING_SOLIDUS */);\r\n        }\r\n        advanceBy(context, isSelfClosing ? 2 : 1);\r\n    }\r\n    return {\r\n        type: 1 /* ELEMENT */,\r\n        ns,\r\n        tag,\r\n        tagType,\r\n        props,\r\n        isSelfClosing,\r\n        children: [],\r\n        loc: getSelection(context, start),\r\n        codegenNode: undefined // to be created during transform phase\r\n    };\r\n}\r\nfunction parseAttribute(context, nameSet) {\r\n    __DEV__ && assert(/^[^\\t\\r\\n\\f />]/.test(context.source));\r\n    // Name.\r\n    const start = getCursor(context);\r\n    const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\r\n    const name = match[0];\r\n    if (nameSet.has(name)) {\r\n        emitError(context, 5 /* DUPLICATE_ATTRIBUTE */);\r\n    }\r\n    nameSet.add(name);\r\n    if (name[0] === '=') {\r\n        emitError(context, 26 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);\r\n    }\r\n    {\r\n        const pattern = /[\"'<]/g;\r\n        let m;\r\n        while ((m = pattern.exec(name)) !== null) {\r\n            emitError(context, 24 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);\r\n        }\r\n    }\r\n    advanceBy(context, name.length);\r\n    // Value\r\n    let value = undefined;\r\n    if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\r\n        advanceSpaces(context);\r\n        advanceBy(context, 1);\r\n        advanceSpaces(context);\r\n        value = parseAttributeValue(context);\r\n        if (!value) {\r\n            emitError(context, 16 /* MISSING_ATTRIBUTE_VALUE */);\r\n        }\r\n    }\r\n    const loc = getSelection(context, start);\r\n    if (/^(v-|:|@|#)/.test(name)) {\r\n        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec(name);\r\n        let arg;\r\n        if (match[2]) {\r\n            const startOffset = name.split(match[2], 2).shift().length;\r\n            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length));\r\n            let content = match[2];\r\n            let isStatic = true;\r\n            if (content.startsWith('[')) {\r\n                isStatic = false;\r\n                if (!content.endsWith(']')) {\r\n                    emitError(context, 34 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);\r\n                }\r\n                content = content.substr(1, content.length - 2);\r\n            }\r\n            arg = {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content,\r\n                isStatic,\r\n                loc\r\n            };\r\n        }\r\n        if (value && value.isQuoted) {\r\n            const valueLoc = value.loc;\r\n            valueLoc.start.offset++;\r\n            valueLoc.start.column++;\r\n            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\r\n            valueLoc.source = valueLoc.source.slice(1, -1);\r\n        }\r\n        return {\r\n            type: 7 /* DIRECTIVE */,\r\n            name: match[1] ||\r\n                (startsWith(name, ':')\r\n                    ? 'bind'\r\n                    : startsWith(name, '@')\r\n                        ? 'on'\r\n                        : 'slot'),\r\n            exp: value && {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content: value.content,\r\n                isStatic: false,\r\n                loc: value.loc\r\n            },\r\n            arg,\r\n            modifiers: match[3] ? match[3].substr(1).split('.') : [],\r\n            loc\r\n        };\r\n    }\r\n    return {\r\n        type: 6 /* ATTRIBUTE */,\r\n        name,\r\n        value: value && {\r\n            type: 2 /* TEXT */,\r\n            content: value.content,\r\n            isEmpty: value.content.trim().length === 0,\r\n            loc: value.loc\r\n        },\r\n        loc\r\n    };\r\n}\r\nfunction parseAttributeValue(context) {\r\n    const start = getCursor(context);\r\n    let content;\r\n    const quote = context.source[0];\r\n    const isQuoted = quote === `\"` || quote === `'`;\r\n    if (isQuoted) {\r\n        // Quoted value.\r\n        advanceBy(context, 1);\r\n        const endIndex = context.source.indexOf(quote);\r\n        if (endIndex === -1) {\r\n            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);\r\n        }\r\n        else {\r\n            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);\r\n            advanceBy(context, 1);\r\n        }\r\n    }\r\n    else {\r\n        // Unquoted\r\n        const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\r\n        if (!match) {\r\n            return undefined;\r\n        }\r\n        let unexpectedChars = /[\"'<=`]/g;\r\n        let m;\r\n        while ((m = unexpectedChars.exec(match[0])) !== null) {\r\n            emitError(context, 25 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);\r\n        }\r\n        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);\r\n    }\r\n    return { content, isQuoted, loc: getSelection(context, start) };\r\n}\r\nfunction parseInterpolation(context, mode) {\r\n    const [open, close] = context.options.delimiters;\r\n    __DEV__ && assert(startsWith(context.source, open));\r\n    const closeIndex = context.source.indexOf(close, open.length);\r\n    if (closeIndex === -1) {\r\n        emitError(context, 33 /* X_MISSING_INTERPOLATION_END */);\r\n        return undefined;\r\n    }\r\n    const start = getCursor(context);\r\n    advanceBy(context, open.length);\r\n    const innerStart = getCursor(context);\r\n    const innerEnd = getCursor(context);\r\n    const rawContentLength = closeIndex - open.length;\r\n    const rawContent = context.source.slice(0, rawContentLength);\r\n    const preTrimContent = parseTextData(context, rawContentLength, mode);\r\n    const content = preTrimContent.trim();\r\n    const startOffset = preTrimContent.indexOf(content);\r\n    if (startOffset > 0) {\r\n        advancePositionWithMutation(innerStart, rawContent, startOffset);\r\n    }\r\n    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\r\n    advancePositionWithMutation(innerEnd, rawContent, endOffset);\r\n    advanceBy(context, close.length);\r\n    return {\r\n        type: 5 /* INTERPOLATION */,\r\n        content: {\r\n            type: 4 /* SIMPLE_EXPRESSION */,\r\n            isStatic: false,\r\n            content,\r\n            loc: getSelection(context, innerStart, innerEnd)\r\n        },\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseText(context, mode) {\r\n    __DEV__ && assert(context.source.length > 0);\r\n    const [open] = context.options.delimiters;\r\n    const endIndex = Math.min(...[\r\n        context.source.indexOf('<', 1),\r\n        context.source.indexOf(open, 1),\r\n        mode === 3 /* CDATA */ ? context.source.indexOf(']]>') : -1,\r\n        context.source.length\r\n    ].filter(n => n !== -1));\r\n    __DEV__ && assert(endIndex > 0);\r\n    const start = getCursor(context);\r\n    const content = parseTextData(context, endIndex, mode);\r\n    return {\r\n        type: 2 /* TEXT */,\r\n        content,\r\n        loc: getSelection(context, start),\r\n        isEmpty: !content.trim()\r\n    };\r\n}\r\n/**\r\n * Get text data with a given length from the current location.\r\n * This translates HTML entities in the text data.\r\n */\r\nfunction parseTextData(context, length, mode) {\r\n    if (mode === 2 /* RAWTEXT */ || mode === 3 /* CDATA */) {\r\n        const text = context.source.slice(0, length);\r\n        advanceBy(context, length);\r\n        return text;\r\n    }\r\n    // DATA or RCDATA. Entity decoding required.\r\n    const end = context.offset + length;\r\n    let text = '';\r\n    while (context.offset < end) {\r\n        const head = /&(?:#x?)?/i.exec(context.source);\r\n        if (!head || context.offset + head.index >= end) {\r\n            const remaining = end - context.offset;\r\n            text += context.source.slice(0, remaining);\r\n            advanceBy(context, remaining);\r\n            break;\r\n        }\r\n        // Advance to the \"&\".\r\n        text += context.source.slice(0, head.index);\r\n        advanceBy(context, head.index);\r\n        if (head[0] === '&') {\r\n            // Named character reference.\r\n            let name = '', value = undefined;\r\n            if (/[0-9a-z]/i.test(context.source[1])) {\r\n                for (let length = context.maxCRNameLength; !value && length > 0; --length) {\r\n                    name = context.source.substr(1, length);\r\n                    value = context.options.namedCharacterReferences[name];\r\n                }\r\n                if (value) {\r\n                    const semi = name.endsWith(';');\r\n                    if (mode === 4 /* ATTRIBUTE_VALUE */ &&\r\n                        !semi &&\r\n                        /[=a-z0-9]/i.test(context.source[1 + name.length] || '')) {\r\n                        text += '&';\r\n                        text += name;\r\n                        advanceBy(context, 1 + name.length);\r\n                    }\r\n                    else {\r\n                        text += value;\r\n                        advanceBy(context, 1 + name.length);\r\n                        if (!semi) {\r\n                            emitError(context, 18 /* MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE */);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    emitError(context, 30 /* UNKNOWN_NAMED_CHARACTER_REFERENCE */);\r\n                    text += '&';\r\n                    text += name;\r\n                    advanceBy(context, 1 + name.length);\r\n                }\r\n            }\r\n            else {\r\n                text += '&';\r\n                advanceBy(context, 1);\r\n            }\r\n        }\r\n        else {\r\n            // Numeric character reference.\r\n            const hex = head[0] === '&#x';\r\n            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;\r\n            const body = pattern.exec(context.source);\r\n            if (!body) {\r\n                text += head[0];\r\n                emitError(context, 1 /* ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE */);\r\n                advanceBy(context, head[0].length);\r\n            }\r\n            else {\r\n                // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\r\n                let cp = Number.parseInt(body[1], hex ? 16 : 10);\r\n                if (cp === 0) {\r\n                    emitError(context, 22 /* NULL_CHARACTER_REFERENCE */);\r\n                    cp = 0xfffd;\r\n                }\r\n                else if (cp > 0x10ffff) {\r\n                    emitError(context, 3 /* CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE */);\r\n                    cp = 0xfffd;\r\n                }\r\n                else if (cp >= 0xd800 && cp <= 0xdfff) {\r\n                    emitError(context, 23 /* SURROGATE_CHARACTER_REFERENCE */);\r\n                    cp = 0xfffd;\r\n                }\r\n                else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {\r\n                    emitError(context, 21 /* NONCHARACTER_CHARACTER_REFERENCE */);\r\n                }\r\n                else if ((cp >= 0x01 && cp <= 0x08) ||\r\n                    cp === 0x0b ||\r\n                    (cp >= 0x0d && cp <= 0x1f) ||\r\n                    (cp >= 0x7f && cp <= 0x9f)) {\r\n                    emitError(context, 4 /* CONTROL_CHARACTER_REFERENCE */);\r\n                    cp = CCR_REPLACEMENTS[cp] || cp;\r\n                }\r\n                text += String.fromCodePoint(cp);\r\n                advanceBy(context, body[0].length);\r\n                if (!body[0].endsWith(';')) {\r\n                    emitError(context, 18 /* MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE */);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return text;\r\n}\r\nfunction getCursor(context) {\r\n    const { column, line, offset } = context;\r\n    return { column, line, offset };\r\n}\r\nfunction getSelection(context, start, end) {\r\n    end = end || getCursor(context);\r\n    return {\r\n        start,\r\n        end,\r\n        source: context.originalSource.slice(start.offset, end.offset)\r\n    };\r\n}\r\nfunction last(xs) {\r\n    return xs[xs.length - 1];\r\n}\r\nfunction startsWith(source, searchString) {\r\n    return source.startsWith(searchString);\r\n}\r\nfunction advanceBy(context, numberOfCharacters) {\r\n    const { source } = context;\r\n    __DEV__ && assert(numberOfCharacters <= source.length);\r\n    advancePositionWithMutation(context, source, numberOfCharacters);\r\n    context.source = source.slice(numberOfCharacters);\r\n}\r\nfunction advanceSpaces(context) {\r\n    const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\r\n    if (match) {\r\n        advanceBy(context, match[0].length);\r\n    }\r\n}\r\nfunction getNewPosition(context, start, numberOfCharacters) {\r\n    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);\r\n}\r\nfunction emitError(context, code, offset) {\r\n    const loc = getCursor(context);\r\n    if (offset) {\r\n        loc.offset += offset;\r\n        loc.column += offset;\r\n    }\r\n    context.options.onError(createCompilerError(code, {\r\n        start: loc,\r\n        end: loc,\r\n        source: ''\r\n    }));\r\n}\r\nfunction isEnd(context, mode, ancestors) {\r\n    const s = context.source;\r\n    switch (mode) {\r\n        case 0 /* DATA */:\r\n            if (startsWith(s, '</')) {\r\n                //TODO: probably bad performance\r\n                for (let i = ancestors.length - 1; i >= 0; --i) {\r\n                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case 1 /* RCDATA */:\r\n        case 2 /* RAWTEXT */: {\r\n            const parent = last(ancestors);\r\n            if (parent && startsWithEndTagOpen(s, parent.tag)) {\r\n                return true;\r\n            }\r\n            break;\r\n        }\r\n        case 3 /* CDATA */:\r\n            if (startsWith(s, ']]>')) {\r\n                return true;\r\n            }\r\n            break;\r\n    }\r\n    return !s;\r\n}\r\nfunction startsWithEndTagOpen(source, tag) {\r\n    return (startsWith(source, '</') &&\r\n        source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&\r\n        /[\\t\\n\\f />]/.test(source[2 + tag.length] || '>'));\r\n}\r\n// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\r\nconst CCR_REPLACEMENTS = {\r\n    0x80: 0x20ac,\r\n    0x82: 0x201a,\r\n    0x83: 0x0192,\r\n    0x84: 0x201e,\r\n    0x85: 0x2026,\r\n    0x86: 0x2020,\r\n    0x87: 0x2021,\r\n    0x88: 0x02c6,\r\n    0x89: 0x2030,\r\n    0x8a: 0x0160,\r\n    0x8b: 0x2039,\r\n    0x8c: 0x0152,\r\n    0x8e: 0x017d,\r\n    0x91: 0x2018,\r\n    0x92: 0x2019,\r\n    0x93: 0x201c,\r\n    0x94: 0x201d,\r\n    0x95: 0x2022,\r\n    0x96: 0x2013,\r\n    0x97: 0x2014,\r\n    0x98: 0x02dc,\r\n    0x99: 0x2122,\r\n    0x9a: 0x0161,\r\n    0x9b: 0x203a,\r\n    0x9c: 0x0153,\r\n    0x9e: 0x017e,\r\n    0x9f: 0x0178\r\n};\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/errors.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/utils.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/ast.ts"]}
