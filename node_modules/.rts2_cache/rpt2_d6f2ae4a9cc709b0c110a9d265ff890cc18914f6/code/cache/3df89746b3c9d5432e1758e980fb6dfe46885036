{"code":"import { createObjectExpression, createObjectProperty, createSimpleExpression, createFunctionExpression, createConditionalExpression, createCallExpression, createArrayExpression } from '../ast';\r\nimport { createCompilerError } from '../errors';\r\nimport { findDir, isTemplateNode, assert, isVSlot } from '../utils';\r\nimport { CREATE_SLOTS, RENDER_LIST } from '../runtimeHelpers';\r\nimport { parseForExpression, createForLoopParams } from './vFor';\r\nconst isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;\r\nconst defaultFallback = createSimpleExpression(`undefined`, false);\r\n// A NodeTransform that:\r\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\r\n//    by transformExpression. This is only applied in non-browser builds with\r\n//    { prefixIdentifiers: true }.\r\n// 2. Track v-slot depths so that we know a slot is inside another slot.\r\n//    Note the exit callback is executed before buildSlots() on the same node,\r\n//    so only nested slots see positive numbers.\r\nexport const trackSlotScopes = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 1 /* COMPONENT */ ||\r\n            node.tagType === 3 /* TEMPLATE */)) {\r\n        // We are only checking non-empty v-slot here\r\n        // since we only care about slots that introduce scope variables.\r\n        const vSlot = findDir(node, 'slot');\r\n        if (vSlot) {\r\n            const slotProps = vSlot.exp;\r\n            if (!__BROWSER__ && context.prefixIdentifiers) {\r\n                slotProps && context.addIdentifiers(slotProps);\r\n            }\r\n            context.scopes.vSlot++;\r\n            return () => {\r\n                if (!__BROWSER__ && context.prefixIdentifiers) {\r\n                    slotProps && context.removeIdentifiers(slotProps);\r\n                }\r\n                context.scopes.vSlot--;\r\n            };\r\n        }\r\n    }\r\n};\r\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\r\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\r\nexport const trackVForSlotScopes = (node, context) => {\r\n    let vFor;\r\n    if (isTemplateNode(node) &&\r\n        node.props.some(isVSlot) &&\r\n        (vFor = findDir(node, 'for'))) {\r\n        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));\r\n        if (result) {\r\n            const { value, key, index } = result;\r\n            const { addIdentifiers, removeIdentifiers } = context;\r\n            value && addIdentifiers(value);\r\n            key && addIdentifiers(key);\r\n            index && addIdentifiers(index);\r\n            return () => {\r\n                value && removeIdentifiers(value);\r\n                key && removeIdentifiers(key);\r\n                index && removeIdentifiers(index);\r\n            };\r\n        }\r\n    }\r\n};\r\n// Instead of being a DirectiveTransform, v-slot processing is called during\r\n// transformElement to build the slots object for a component.\r\nexport function buildSlots(node, context) {\r\n    const { children, loc } = node;\r\n    const slotsProperties = [];\r\n    const dynamicSlots = [];\r\n    // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n    // since it likely uses a scope variable.\r\n    // TODO: This can be further optimized to only make it dynamic when the slot\r\n    // actually uses the scope variables.\r\n    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\r\n    // 1. Check for default slot with slotProps on component itself.\r\n    //    <Comp v-slot=\"{ prop }\"/>\r\n    const explicitDefaultSlot = findDir(node, 'slot', true);\r\n    if (explicitDefaultSlot) {\r\n        const { arg, exp, loc } = explicitDefaultSlot;\r\n        if (arg) {\r\n            context.onError(createCompilerError(42 /* X_NAMED_SLOT_ON_COMPONENT */, loc));\r\n        }\r\n        slotsProperties.push(buildDefaultSlot(exp, children, loc));\r\n    }\r\n    // 2. Iterate through children and check for template slots\r\n    //    <template v-slot:foo=\"{ prop }\">\r\n    let hasTemplateSlots = false;\r\n    let extraneousChild = undefined;\r\n    const seenSlotNames = new Set();\r\n    for (let i = 0; i < children.length; i++) {\r\n        const slotElement = children[i];\r\n        let slotDir;\r\n        if (!isTemplateNode(slotElement) ||\r\n            !(slotDir = findDir(slotElement, 'slot', true))) {\r\n            // not a <template v-slot>, skip.\r\n            if (slotElement.type !== 3 /* COMMENT */ && !extraneousChild) {\r\n                extraneousChild = slotElement;\r\n            }\r\n            continue;\r\n        }\r\n        if (explicitDefaultSlot) {\r\n            // already has on-component default slot - this is incorrect usage.\r\n            context.onError(createCompilerError(43 /* X_MIXED_SLOT_USAGE */, slotDir.loc));\r\n            break;\r\n        }\r\n        hasTemplateSlots = true;\r\n        const { children: slotChildren, loc: slotLoc } = slotElement;\r\n        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;\r\n        // check if name is dynamic.\r\n        let staticSlotName;\r\n        if (isStaticExp(slotName)) {\r\n            staticSlotName = slotName ? slotName.content : `default`;\r\n        }\r\n        else {\r\n            hasDynamicSlots = true;\r\n        }\r\n        const slotFunction = createFunctionExpression(slotProps, slotChildren, false, slotChildren.length ? slotChildren[0].loc : slotLoc);\r\n        // check if this slot is conditional (v-if/v-for)\r\n        let vIf;\r\n        let vElse;\r\n        let vFor;\r\n        if ((vIf = findDir(slotElement, 'if'))) {\r\n            hasDynamicSlots = true;\r\n            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));\r\n        }\r\n        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {\r\n            // find adjacent v-if\r\n            let j = i;\r\n            let prev;\r\n            while (j--) {\r\n                prev = children[j];\r\n                if (prev.type !== 3 /* COMMENT */) {\r\n                    break;\r\n                }\r\n            }\r\n            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\r\n                // remove node\r\n                children.splice(i, 1);\r\n                i--;\r\n                __DEV__ && assert(dynamicSlots.length > 0);\r\n                // attach this slot to previous conditional\r\n                let conditional = dynamicSlots[dynamicSlots.length - 1];\r\n                while (conditional.alternate.type === 18 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                    conditional = conditional.alternate;\r\n                }\r\n                conditional.alternate = vElse.exp\r\n                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)\r\n                    : buildDynamicSlot(slotName, slotFunction);\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(36 /* X_ELSE_NO_ADJACENT_IF */, vElse.loc));\r\n            }\r\n        }\r\n        else if ((vFor = findDir(slotElement, 'for'))) {\r\n            hasDynamicSlots = true;\r\n            const parseResult = vFor.parseResult ||\r\n                parseForExpression(vFor.exp, context);\r\n            if (parseResult) {\r\n                // Render the dynamic slots as an array and add it to the createSlot()\r\n                // args. The runtime knows how to handle it appropriately.\r\n                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [\r\n                    parseResult.source,\r\n                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)\r\n                ]));\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(38 /* X_FOR_MALFORMED_EXPRESSION */, vFor.loc));\r\n            }\r\n        }\r\n        else {\r\n            // check duplicate static names\r\n            if (staticSlotName) {\r\n                if (seenSlotNames.has(staticSlotName)) {\r\n                    context.onError(createCompilerError(44 /* X_DUPLICATE_SLOT_NAMES */, dirLoc));\r\n                    continue;\r\n                }\r\n                seenSlotNames.add(staticSlotName);\r\n            }\r\n            slotsProperties.push(createObjectProperty(slotName, slotFunction));\r\n        }\r\n    }\r\n    if (hasTemplateSlots && extraneousChild) {\r\n        context.onError(createCompilerError(45 /* X_EXTRANEOUS_NON_SLOT_CHILDREN */, extraneousChild.loc));\r\n    }\r\n    if (!explicitDefaultSlot && !hasTemplateSlots) {\r\n        // implicit default slot.\r\n        slotsProperties.push(buildDefaultSlot(undefined, children, loc));\r\n    }\r\n    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_compiled`, createSimpleExpression(`true`, false))), loc);\r\n    if (dynamicSlots.length) {\r\n        slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n            slots,\r\n            createArrayExpression(dynamicSlots)\r\n        ]);\r\n    }\r\n    return {\r\n        slots,\r\n        hasDynamicSlots\r\n    };\r\n}\r\nfunction buildDefaultSlot(slotProps, children, loc) {\r\n    return createObjectProperty(`default`, createFunctionExpression(slotProps, children, false, children.length ? children[0].loc : loc));\r\n}\r\nfunction buildDynamicSlot(name, fn) {\r\n    return createObjectExpression([\r\n        createObjectProperty(`name`, name),\r\n        createObjectProperty(`fn`, fn)\r\n    ]);\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/ast.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transform.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/errors.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/utils.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/runtimeHelpers.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transforms/vFor.ts"]}
