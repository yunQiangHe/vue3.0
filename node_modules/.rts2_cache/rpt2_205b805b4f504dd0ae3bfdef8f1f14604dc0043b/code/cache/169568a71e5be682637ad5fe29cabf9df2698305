{"code":"import { isObject, toTypeString } from '@vue/shared';\r\nimport { mutableHandlers, readonlyHandlers } from './baseHandlers';\r\nimport { mutableCollectionHandlers, readonlyCollectionHandlers } from './collectionHandlers';\r\nexport const targetMap = new WeakMap();\r\n// WeakMaps that store {raw <-> observed} pairs.\r\nconst rawToReactive = new WeakMap();\r\nconst reactiveToRaw = new WeakMap();\r\nconst rawToReadonly = new WeakMap();\r\nconst readonlyToRaw = new WeakMap();\r\n// WeakSets for values that are marked readonly or non-reactive during\r\n// observable creation.\r\nconst readonlyValues = new WeakSet();\r\nconst nonReactiveValues = new WeakSet();\r\nconst collectionTypes = new Set([Set, Map, WeakMap, WeakSet]);\r\nconst observableValueRE = /^\\[object (?:Object|Array|Map|Set|WeakMap|WeakSet)\\]$/;\r\nconst canObserve = (value) => {\r\n    return (!value._isVue &&\r\n        !value._isVNode &&\r\n        observableValueRE.test(toTypeString(value)) &&\r\n        !nonReactiveValues.has(value));\r\n};\r\nexport function reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (readonlyToRaw.has(target)) {\r\n        return target;\r\n    }\r\n    // target is explicitly marked as readonly by user\r\n    if (readonlyValues.has(target)) {\r\n        return readonly(target);\r\n    }\r\n    return createReactiveObject(target, rawToReactive, reactiveToRaw, mutableHandlers, mutableCollectionHandlers);\r\n}\r\nexport function readonly(target) {\r\n    // value is a mutable observable, retrieve its original and return\r\n    // a readonly version.\r\n    if (reactiveToRaw.has(target)) {\r\n        target = reactiveToRaw.get(target);\r\n    }\r\n    return createReactiveObject(target, rawToReadonly, readonlyToRaw, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, toProxy, toRaw, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if (__DEV__) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    let observed = toProxy.get(target);\r\n    if (observed !== void 0) {\r\n        return observed;\r\n    }\r\n    // target is already a Proxy\r\n    if (toRaw.has(target)) {\r\n        return target;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    if (!canObserve(target)) {\r\n        return target;\r\n    }\r\n    const handlers = collectionTypes.has(target.constructor)\r\n        ? collectionHandlers\r\n        : baseHandlers;\r\n    observed = new Proxy(target, handlers);\r\n    toProxy.set(target, observed);\r\n    toRaw.set(observed, target);\r\n    if (!targetMap.has(target)) {\r\n        targetMap.set(target, new Map());\r\n    }\r\n    return observed;\r\n}\r\nexport function isReactive(value) {\r\n    return reactiveToRaw.has(value) || readonlyToRaw.has(value);\r\n}\r\nexport function isReadonly(value) {\r\n    return readonlyToRaw.has(value);\r\n}\r\nexport function toRaw(observed) {\r\n    return reactiveToRaw.get(observed) || readonlyToRaw.get(observed) || observed;\r\n}\r\nexport function markReadonly(value) {\r\n    readonlyValues.add(value);\r\n    return value;\r\n}\r\nexport function markNonReactive(value) {\r\n    nonReactiveValues.add(value);\r\n    return value;\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/baseHandlers.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/collectionHandlers.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/ref.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/effect.ts"]}
