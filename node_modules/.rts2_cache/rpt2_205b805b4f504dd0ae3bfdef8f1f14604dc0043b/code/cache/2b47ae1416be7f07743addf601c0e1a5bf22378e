{"code":"import { isFunction, extend, isString, isObject, isArray, EMPTY_OBJ } from '@vue/shared';\r\nimport { computed } from './apiReactivity';\r\nimport { watch } from './apiWatch';\r\nimport { provide, inject } from './apiInject';\r\nimport { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onErrorCaptured, onRenderTracked, onBeforeUnmount, onUnmounted, onRenderTriggered } from './apiLifecycle';\r\nimport { reactive } from '@vue/reactivity';\r\nimport { warn } from './warning';\r\nexport function applyOptions(instance, options, asMixin = false) {\r\n    const renderContext = instance.renderContext === EMPTY_OBJ\r\n        ? (instance.renderContext = reactive({}))\r\n        : instance.renderContext;\r\n    const ctx = instance.renderProxy;\r\n    const { \r\n    // composition\r\n    mixins, extends: extendsOptions, \r\n    // state\r\n    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \r\n    // assets\r\n    components, directives, \r\n    // lifecycle\r\n    beforeMount, mounted, beforeUpdate, updated, \r\n    // TODO activated\r\n    // TODO deactivated\r\n    beforeUnmount, unmounted, renderTracked, renderTriggered, errorCaptured } = options;\r\n    const globalMixins = instance.appContext.mixins;\r\n    // applyOptions is called non-as-mixin once per instance\r\n    if (!asMixin) {\r\n        callSyncHook('beforeCreate', options, ctx, globalMixins);\r\n        // global mixins are applied first\r\n        applyMixins(instance, globalMixins);\r\n    }\r\n    // extending a base component...\r\n    if (extendsOptions) {\r\n        applyOptions(instance, extendsOptions, true);\r\n    }\r\n    // local mixins\r\n    if (mixins) {\r\n        applyMixins(instance, mixins);\r\n    }\r\n    // state options\r\n    if (dataOptions) {\r\n        const data = isFunction(dataOptions) ? dataOptions.call(ctx) : dataOptions;\r\n        if (!isObject(data)) {\r\n            __DEV__ && warn(`data() should return an object.`);\r\n        }\r\n        else if (instance.data === EMPTY_OBJ) {\r\n            instance.data = reactive(data);\r\n        }\r\n        else {\r\n            // existing data: this is a mixin or extends.\r\n            extend(instance.data, data);\r\n        }\r\n    }\r\n    if (computedOptions) {\r\n        for (const key in computedOptions) {\r\n            const opt = computedOptions[key];\r\n            renderContext[key] = isFunction(opt)\r\n                ? computed(opt.bind(ctx))\r\n                : computed({\r\n                    get: opt.get.bind(ctx),\r\n                    set: opt.set.bind(ctx)\r\n                });\r\n        }\r\n    }\r\n    if (methods) {\r\n        for (const key in methods) {\r\n            renderContext[key] = methods[key].bind(ctx);\r\n        }\r\n    }\r\n    if (watchOptions) {\r\n        for (const key in watchOptions) {\r\n            const raw = watchOptions[key];\r\n            const getter = () => ctx[key];\r\n            if (isString(raw)) {\r\n                const handler = renderContext[raw];\r\n                if (isFunction(handler)) {\r\n                    watch(getter, handler);\r\n                }\r\n                else if (__DEV__) {\r\n                    // TODO warn invalid watch handler path\r\n                }\r\n            }\r\n            else if (isFunction(raw)) {\r\n                watch(getter, raw.bind(ctx));\r\n            }\r\n            else if (isObject(raw)) {\r\n                // TODO 2.x compat\r\n                watch(getter, raw.handler.bind(ctx), raw);\r\n            }\r\n            else if (__DEV__) {\r\n                // TODO warn invalid watch options\r\n            }\r\n        }\r\n    }\r\n    if (provideOptions) {\r\n        const provides = isFunction(provideOptions)\r\n            ? provideOptions.call(ctx)\r\n            : provideOptions;\r\n        for (const key in provides) {\r\n            provide(key, provides[key]);\r\n        }\r\n    }\r\n    if (injectOptions) {\r\n        if (isArray(injectOptions)) {\r\n            for (let i = 0; i < injectOptions.length; i++) {\r\n                const key = injectOptions[i];\r\n                renderContext[key] = inject(key);\r\n            }\r\n        }\r\n        else {\r\n            for (const key in injectOptions) {\r\n                const opt = injectOptions[key];\r\n                if (isObject(opt)) {\r\n                    renderContext[key] = inject(opt.from, opt.default);\r\n                }\r\n                else {\r\n                    renderContext[key] = inject(opt);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // asset options\r\n    if (components) {\r\n        extend(instance.components, components);\r\n    }\r\n    if (directives) {\r\n        extend(instance.directives, directives);\r\n    }\r\n    // lifecycle options\r\n    if (!asMixin) {\r\n        callSyncHook('created', options, ctx, globalMixins);\r\n    }\r\n    if (beforeMount) {\r\n        onBeforeMount(beforeMount.bind(ctx));\r\n    }\r\n    if (mounted) {\r\n        onMounted(mounted.bind(ctx));\r\n    }\r\n    if (beforeUpdate) {\r\n        onBeforeUpdate(beforeUpdate.bind(ctx));\r\n    }\r\n    if (updated) {\r\n        onUpdated(updated.bind(ctx));\r\n    }\r\n    if (errorCaptured) {\r\n        onErrorCaptured(errorCaptured.bind(ctx));\r\n    }\r\n    if (renderTracked) {\r\n        onRenderTracked(renderTracked.bind(ctx));\r\n    }\r\n    if (renderTriggered) {\r\n        onRenderTriggered(renderTriggered.bind(ctx));\r\n    }\r\n    if (beforeUnmount) {\r\n        onBeforeUnmount(beforeUnmount.bind(ctx));\r\n    }\r\n    if (unmounted) {\r\n        onUnmounted(unmounted.bind(ctx));\r\n    }\r\n}\r\nfunction callSyncHook(name, options, ctx, globalMixins) {\r\n    callHookFromMixins(name, globalMixins, ctx);\r\n    const baseHook = options.extends && options.extends[name];\r\n    if (baseHook) {\r\n        baseHook.call(ctx);\r\n    }\r\n    const mixins = options.mixins;\r\n    if (mixins) {\r\n        callHookFromMixins(name, mixins, ctx);\r\n    }\r\n    const selfHook = options[name];\r\n    if (selfHook) {\r\n        selfHook.call(ctx);\r\n    }\r\n}\r\nfunction callHookFromMixins(name, mixins, ctx) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        const fn = mixins[i][name];\r\n        if (fn) {\r\n            fn.call(ctx);\r\n        }\r\n    }\r\n}\r\nfunction applyMixins(instance, mixins) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        applyOptions(instance, mixins[i], true);\r\n    }\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/component.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiReactivity.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiWatch.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiInject.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiLifecycle.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentProps.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/directives.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/vnode.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentProxy.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/warning.ts"]}
