{"code":"import { createStructuralDirectiveTransform } from '../transform';\r\nimport { createSimpleExpression, createSequenceExpression, createCallExpression, createFunctionExpression, createObjectExpression, createObjectProperty } from '../ast';\r\nimport { createCompilerError } from '../errors';\r\nimport { getInnerRange, findProp, createBlockExpression, isTemplateNode, isSlotOutlet, injectProp } from '../utils';\r\nimport { RENDER_LIST, OPEN_BLOCK, CREATE_BLOCK, FRAGMENT } from '../runtimeHelpers';\r\nimport { processExpression } from './transformExpression';\r\nimport { PatchFlagNames } from '@vue/shared';\r\nexport const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {\r\n    if (dir.exp) {\r\n        const parseResult = parseForExpression(\r\n        // can only be simple expression because vFor transform is applied\r\n        // before expression transform.\r\n        dir.exp, context);\r\n        if (parseResult) {\r\n            const { helper, addIdentifiers, removeIdentifiers, scopes } = context;\r\n            const { source, value, key, index } = parseResult;\r\n            // create the loop render function expression now, and add the\r\n            // iterator on exit after all children have been traversed\r\n            const renderExp = createCallExpression(helper(RENDER_LIST), [source]);\r\n            const keyProp = findProp(node, `key`);\r\n            const fragmentFlag = keyProp\r\n                ? 64 /* KEYED_FRAGMENT */\r\n                : 128 /* UNKEYED_FRAGMENT */;\r\n            const codegenNode = createSequenceExpression([\r\n                createCallExpression(helper(OPEN_BLOCK)),\r\n                createCallExpression(helper(CREATE_BLOCK), [\r\n                    helper(FRAGMENT),\r\n                    `null`,\r\n                    renderExp,\r\n                    fragmentFlag +\r\n                        (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``)\r\n                ])\r\n            ]);\r\n            context.replaceNode({\r\n                type: 11 /* FOR */,\r\n                loc: dir.loc,\r\n                source,\r\n                valueAlias: value,\r\n                keyAlias: key,\r\n                objectIndexAlias: index,\r\n                children: node.tagType === 3 /* TEMPLATE */ ? node.children : [node],\r\n                codegenNode\r\n            });\r\n            // bookkeeping\r\n            scopes.vFor++;\r\n            if (!__BROWSER__ && context.prefixIdentifiers) {\r\n                // scope management\r\n                // inject identifiers to context\r\n                value && addIdentifiers(value);\r\n                key && addIdentifiers(key);\r\n                index && addIdentifiers(index);\r\n            }\r\n            return () => {\r\n                scopes.vFor--;\r\n                if (!__BROWSER__ && context.prefixIdentifiers) {\r\n                    value && removeIdentifiers(value);\r\n                    key && removeIdentifiers(key);\r\n                    index && removeIdentifiers(index);\r\n                }\r\n                // finish the codegen now that all children have been traversed\r\n                let childBlock;\r\n                const isTemplate = isTemplateNode(node);\r\n                const slotOutlet = isSlotOutlet(node)\r\n                    ? node\r\n                    : isTemplate &&\r\n                        node.children.length === 1 &&\r\n                        isSlotOutlet(node.children[0])\r\n                        ? node.children[0]\r\n                        : null;\r\n                const keyProperty = keyProp\r\n                    ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */\r\n                        ? createSimpleExpression(keyProp.value.content, true)\r\n                        : keyProp.exp)\r\n                    : null;\r\n                if (slotOutlet) {\r\n                    // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\r\n                    childBlock = slotOutlet.codegenNode;\r\n                    if (isTemplate && keyProperty) {\r\n                        // <template v-for=\"...\" :key=\"...\"><slot/></template>\r\n                        // we need to inject the key to the renderSlot() call.\r\n                        // the props for renderSlot is passed as the 3rd argument.\r\n                        const existingProps = childBlock.arguments[2];\r\n                        childBlock.arguments[2] = injectProp(existingProps, keyProperty, context);\r\n                    }\r\n                }\r\n                else if (isTemplate) {\r\n                    // <template v-for=\"...\">\r\n                    // should generate a fragment block for each loop\r\n                    childBlock = createBlockExpression([\r\n                        helper(FRAGMENT),\r\n                        keyProperty ? createObjectExpression([keyProperty]) : `null`,\r\n                        node.children\r\n                    ], context);\r\n                }\r\n                else {\r\n                    // Normal element v-for. Directly use the child's codegenNode\r\n                    // arguments, but replace createVNode() with createBlock()\r\n                    childBlock = createBlockExpression(node.codegenNode.arguments, context);\r\n                }\r\n                renderExp.arguments.push(createFunctionExpression(createForLoopParams(parseResult), childBlock, true /* force newline */));\r\n            };\r\n        }\r\n        else {\r\n            context.onError(createCompilerError(38 /* X_FOR_MALFORMED_EXPRESSION */, dir.loc));\r\n        }\r\n    }\r\n    else {\r\n        context.onError(createCompilerError(37 /* X_FOR_NO_EXPRESSION */, dir.loc));\r\n    }\r\n});\r\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\r\n// This regex doesn't cover the case if key or index aliases have destructuring,\r\n// but those do not make sense in the first place, so this works in practice.\r\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\r\nconst stripParensRE = /^\\(|\\)$/g;\r\nexport function parseForExpression(input, context) {\r\n    const loc = input.loc;\r\n    const exp = input.content;\r\n    const inMatch = exp.match(forAliasRE);\r\n    if (!inMatch)\r\n        return;\r\n    const [, LHS, RHS] = inMatch;\r\n    const result = {\r\n        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),\r\n        value: undefined,\r\n        key: undefined,\r\n        index: undefined\r\n    };\r\n    if (!__BROWSER__ && context.prefixIdentifiers) {\r\n        result.source = processExpression(result.source, context);\r\n    }\r\n    let valueContent = LHS.trim()\r\n        .replace(stripParensRE, '')\r\n        .trim();\r\n    const trimmedOffset = LHS.indexOf(valueContent);\r\n    const iteratorMatch = valueContent.match(forIteratorRE);\r\n    if (iteratorMatch) {\r\n        valueContent = valueContent.replace(forIteratorRE, '').trim();\r\n        const keyContent = iteratorMatch[1].trim();\r\n        let keyOffset;\r\n        if (keyContent) {\r\n            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\r\n            result.key = createAliasExpression(loc, keyContent, keyOffset);\r\n            if (!__BROWSER__ && context.prefixIdentifiers) {\r\n                result.key = processExpression(result.key, context, true);\r\n            }\r\n        }\r\n        if (iteratorMatch[2]) {\r\n            const indexContent = iteratorMatch[2].trim();\r\n            if (indexContent) {\r\n                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key\r\n                    ? keyOffset + keyContent.length\r\n                    : trimmedOffset + valueContent.length));\r\n                if (!__BROWSER__ && context.prefixIdentifiers) {\r\n                    result.index = processExpression(result.index, context, true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (valueContent) {\r\n        result.value = createAliasExpression(loc, valueContent, trimmedOffset);\r\n        if (!__BROWSER__ && context.prefixIdentifiers) {\r\n            result.value = processExpression(result.value, context, true);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction createAliasExpression(range, content, offset) {\r\n    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));\r\n}\r\nexport function createForLoopParams({ value, key, index }) {\r\n    const params = [];\r\n    if (value) {\r\n        params.push(value);\r\n    }\r\n    if (key) {\r\n        if (!value) {\r\n            params.push(createSimpleExpression(`_`, false));\r\n        }\r\n        params.push(key);\r\n    }\r\n    if (index) {\r\n        if (!key) {\r\n            if (!value) {\r\n                params.push(createSimpleExpression(`_`, false));\r\n            }\r\n            params.push(createSimpleExpression(`__`, false));\r\n        }\r\n        params.push(index);\r\n    }\r\n    return params;\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transform.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/ast.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/errors.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/utils.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/runtimeHelpers.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transforms/transformExpression.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transforms/transformElement.ts"]}
