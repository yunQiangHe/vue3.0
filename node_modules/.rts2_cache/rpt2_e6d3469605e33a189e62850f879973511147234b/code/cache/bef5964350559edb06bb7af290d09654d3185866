{"code":"import { effect, stop, isRef } from '@vue/reactivity';\r\nimport { queueJob } from './scheduler';\r\nimport { EMPTY_OBJ, isObject, isArray, isFunction, isString } from '@vue/shared';\r\nimport { recordEffect } from './apiReactivity';\r\nimport { currentInstance, currentSuspense } from './component';\r\nimport { callWithErrorHandling, callWithAsyncErrorHandling } from './errorHandling';\r\nimport { onBeforeUnmount } from './apiLifecycle';\r\nimport { queuePostRenderEffect } from './createRenderer';\r\nconst invoke = (fn) => fn();\r\n// implementation\r\nexport function watch(effectOrSource, cbOrOptions, options) {\r\n    if (isFunction(cbOrOptions)) {\r\n        // effect callback as 2nd argument - this is a source watcher\r\n        return doWatch(effectOrSource, cbOrOptions, options);\r\n    }\r\n    else {\r\n        // 2nd argument is either missing or an options object\r\n        // - this is a simple effect watcher\r\n        return doWatch(effectOrSource, null, cbOrOptions);\r\n    }\r\n}\r\nfunction doWatch(source, cb, { lazy, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\r\n    const instance = currentInstance;\r\n    const suspense = currentSuspense;\r\n    let getter;\r\n    if (isArray(source)) {\r\n        getter = () => source.map(s => isRef(s)\r\n            ? s.value\r\n            : callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */));\r\n    }\r\n    else if (isRef(source)) {\r\n        getter = () => source.value;\r\n    }\r\n    else if (cb) {\r\n        // getter with cb\r\n        getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n    }\r\n    else {\r\n        // no cb -> simple effect\r\n        getter = () => {\r\n            if (instance && instance.isUnmounted) {\r\n                return;\r\n            }\r\n            if (cleanup) {\r\n                cleanup();\r\n            }\r\n            return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [registerCleanup]);\r\n        };\r\n    }\r\n    if (deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const registerCleanup = (fn) => {\r\n        // TODO wrap the cleanup fn for error handling\r\n        cleanup = runner.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isArray(source) ? [] : undefined;\r\n    const applyCb = cb\r\n        ? () => {\r\n            if (instance && instance.isUnmounted) {\r\n                return;\r\n            }\r\n            const newValue = runner();\r\n            if (deep || newValue !== oldValue) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    oldValue,\r\n                    registerCleanup\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        : void 0;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = invoke;\r\n    }\r\n    else if (flush === 'pre') {\r\n        scheduler = job => {\r\n            if (!instance || instance.vnode.el != null) {\r\n                queueJob(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    else {\r\n        scheduler = job => {\r\n            queuePostRenderEffect(job, suspense);\r\n        };\r\n    }\r\n    const runner = effect(getter, {\r\n        lazy: true,\r\n        // so it runs before component update effects in pre flush mode\r\n        computed: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler: applyCb ? () => scheduler(applyCb) : scheduler\r\n    });\r\n    if (!lazy) {\r\n        if (applyCb) {\r\n            scheduler(applyCb);\r\n        }\r\n        else {\r\n            scheduler(runner);\r\n        }\r\n    }\r\n    else {\r\n        oldValue = runner();\r\n    }\r\n    recordEffect(runner);\r\n    return () => {\r\n        stop(runner);\r\n    };\r\n}\r\n// this.$watch\r\nexport function instanceWatch(source, cb, options) {\r\n    const ctx = this.renderProxy;\r\n    const getter = isString(source) ? () => ctx[source] : source.bind(ctx);\r\n    const stop = watch(getter, cb.bind(ctx), options);\r\n    onBeforeUnmount(stop, this);\r\n    return stop;\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!isObject(value) || seen.has(value)) {\r\n        return;\r\n    }\r\n    seen.add(value);\r\n    if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (value instanceof Map) {\r\n        value.forEach((v, key) => {\r\n            // to register mutation dep for existing keys\r\n            traverse(value.get(key), seen);\r\n        });\r\n    }\r\n    else if (value instanceof Set) {\r\n        value.forEach(v => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/scheduler.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiReactivity.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/component.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/errorHandling.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiLifecycle.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/createRenderer.ts"]}
