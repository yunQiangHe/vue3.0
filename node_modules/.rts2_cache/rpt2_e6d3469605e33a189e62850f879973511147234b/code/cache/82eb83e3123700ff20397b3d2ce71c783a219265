{"code":"import { isVNode } from './vnode';\r\nimport { reactive, readonly } from '@vue/reactivity';\r\nimport { PublicInstanceProxyHandlers } from './componentProxy';\r\nimport { warn } from './warning';\r\nimport { callWithErrorHandling, callWithAsyncErrorHandling } from './errorHandling';\r\nimport { createAppContext } from './apiApp';\r\nimport { applyOptions } from './apiOptions';\r\nimport { EMPTY_OBJ, isFunction, capitalize, NOOP, isArray, isObject } from '@vue/shared';\r\nconst emptyAppContext = createAppContext();\r\nexport function createComponentInstance(vnode, parent) {\r\n    // inherit parent app context - or - if root, adopt from root vnode\r\n    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\r\n    const instance = {\r\n        vnode,\r\n        parent,\r\n        appContext,\r\n        type: vnode.type,\r\n        root: null,\r\n        next: null,\r\n        subTree: null,\r\n        update: null,\r\n        render: null,\r\n        renderProxy: null,\r\n        propsProxy: null,\r\n        setupContext: null,\r\n        effects: null,\r\n        provides: parent ? parent.provides : Object.create(appContext.provides),\r\n        // setup context properties\r\n        renderContext: EMPTY_OBJ,\r\n        data: EMPTY_OBJ,\r\n        props: EMPTY_OBJ,\r\n        attrs: EMPTY_OBJ,\r\n        slots: EMPTY_OBJ,\r\n        refs: EMPTY_OBJ,\r\n        // per-instance asset storage (mutable during options resolution)\r\n        components: Object.create(appContext.components),\r\n        directives: Object.create(appContext.directives),\r\n        // async dependency management\r\n        asyncDep: null,\r\n        asyncResult: null,\r\n        asyncResolved: false,\r\n        // user namespace for storing whatever the user assigns to `this`\r\n        user: {},\r\n        // lifecycle hooks\r\n        // not using enums here because it results in computed properties\r\n        isUnmounted: false,\r\n        bc: null,\r\n        c: null,\r\n        bm: null,\r\n        m: null,\r\n        bu: null,\r\n        u: null,\r\n        um: null,\r\n        bum: null,\r\n        da: null,\r\n        a: null,\r\n        rtg: null,\r\n        rtc: null,\r\n        ec: null,\r\n        emit: (event, ...args) => {\r\n            const props = instance.vnode.props || EMPTY_OBJ;\r\n            const handler = props[`on${event}`] || props[`on${capitalize(event)}`];\r\n            if (handler) {\r\n                if (isArray(handler)) {\r\n                    for (let i = 0; i < handler.length; i++) {\r\n                        callWithAsyncErrorHandling(handler[i], instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n                    }\r\n                }\r\n                else {\r\n                    callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    instance.root = parent ? parent.root : instance;\r\n    return instance;\r\n}\r\nexport let currentInstance = null;\r\nexport let currentSuspense = null;\r\nexport const getCurrentInstance = () => currentInstance;\r\nexport const setCurrentInstance = (instance) => {\r\n    currentInstance = instance;\r\n};\r\nexport function setupStatefulComponent(instance, parentSuspense) {\r\n    const Component = instance.type;\r\n    // 1. create render proxy\r\n    instance.renderProxy = new Proxy(instance, PublicInstanceProxyHandlers);\r\n    // 2. create props proxy\r\n    // the propsProxy is a reactive AND readonly proxy to the actual props.\r\n    // it will be updated in resolveProps() on updates before render\r\n    const propsProxy = (instance.propsProxy = readonly(instance.props));\r\n    // 3. call setup()\r\n    const { setup } = Component;\r\n    if (setup) {\r\n        const setupContext = (instance.setupContext =\r\n            setup.length > 1 ? createSetupContext(instance) : null);\r\n        currentInstance = instance;\r\n        currentSuspense = parentSuspense;\r\n        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [propsProxy, setupContext]);\r\n        currentInstance = null;\r\n        currentSuspense = null;\r\n        if (setupResult &&\r\n            isFunction(setupResult.then) &&\r\n            isFunction(setupResult.catch)) {\r\n            if (__FEATURE_SUSPENSE__) {\r\n                // async setup returned Promise.\r\n                // bail here and wait for re-entry.\r\n                instance.asyncDep = setupResult;\r\n            }\r\n            else if (__DEV__) {\r\n                warn(`setup() returned a Promise, but the version of Vue you are using ` +\r\n                    `does not support it yet.`);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            handleSetupResult(instance, setupResult, parentSuspense);\r\n        }\r\n    }\r\n    else {\r\n        finishComponentSetup(instance, parentSuspense);\r\n    }\r\n}\r\nexport function handleSetupResult(instance, setupResult, parentSuspense) {\r\n    if (isFunction(setupResult)) {\r\n        // setup returned an inline render function\r\n        instance.render = setupResult;\r\n    }\r\n    else if (isObject(setupResult)) {\r\n        if (__DEV__ && isVNode(setupResult)) {\r\n            warn(`setup() should not return VNodes directly - ` +\r\n                `return a render function instead.`);\r\n        }\r\n        // setup returned bindings.\r\n        // assuming a render function compiled from template is present.\r\n        instance.renderContext = reactive(setupResult);\r\n    }\r\n    else if (__DEV__ && setupResult !== undefined) {\r\n        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\r\n    }\r\n    finishComponentSetup(instance, parentSuspense);\r\n}\r\nlet compile;\r\nexport function registerRuntimeCompiler(_compile) {\r\n    compile = _compile;\r\n}\r\nfunction finishComponentSetup(instance, parentSuspense) {\r\n    const Component = instance.type;\r\n    if (!instance.render) {\r\n        if (Component.template && !Component.render) {\r\n            if (compile) {\r\n                Component.render = compile(Component.template, {\r\n                    onError(err) { }\r\n                });\r\n            }\r\n            else if (__DEV__) {\r\n                warn(`Component provides template but the build of Vue you are running ` +\r\n                    `does not support on-the-fly template compilation. Either use the ` +\r\n                    `full build or pre-compile the template using Vue CLI.`);\r\n            }\r\n        }\r\n        if (__DEV__ && !Component.render) {\r\n            warn(`Component is missing render function. Either provide a template or ` +\r\n                `return a render function from setup().`);\r\n        }\r\n        instance.render = (Component.render || NOOP);\r\n    }\r\n    // support for 2.x options\r\n    if (__FEATURE_OPTIONS__) {\r\n        currentInstance = instance;\r\n        currentSuspense = parentSuspense;\r\n        applyOptions(instance, Component);\r\n        currentInstance = null;\r\n        currentSuspense = null;\r\n    }\r\n    if (instance.renderContext === EMPTY_OBJ) {\r\n        instance.renderContext = reactive({});\r\n    }\r\n}\r\n// used to identify a setup context proxy\r\nexport const SetupProxySymbol = Symbol();\r\nconst SetupProxyHandlers = {};\r\n['attrs', 'slots', 'refs'].forEach((type) => {\r\n    SetupProxyHandlers[type] = {\r\n        get: (instance, key) => instance[type][key],\r\n        has: (instance, key) => key === SetupProxySymbol || key in instance[type],\r\n        ownKeys: instance => Reflect.ownKeys(instance[type]),\r\n        // this is necessary for ownKeys to work properly\r\n        getOwnPropertyDescriptor: (instance, key) => Reflect.getOwnPropertyDescriptor(instance[type], key),\r\n        set: () => false,\r\n        deleteProperty: () => false\r\n    };\r\n});\r\nfunction createSetupContext(instance) {\r\n    const context = {\r\n        // attrs, slots & refs are non-reactive, but they need to always expose\r\n        // the latest values (instance.xxx may get replaced during updates) so we\r\n        // need to expose them through a proxy\r\n        attrs: new Proxy(instance, SetupProxyHandlers.attrs),\r\n        slots: new Proxy(instance, SetupProxyHandlers.slots),\r\n        refs: new Proxy(instance, SetupProxyHandlers.refs),\r\n        emit: instance.emit\r\n    };\r\n    return __DEV__ ? Object.freeze(context) : context;\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/vnode.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentProxy.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentProps.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentSlots.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/warning.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/errorHandling.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiApp.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/directives.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiOptions.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/suspense.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-dom/src/index.ts"]}
