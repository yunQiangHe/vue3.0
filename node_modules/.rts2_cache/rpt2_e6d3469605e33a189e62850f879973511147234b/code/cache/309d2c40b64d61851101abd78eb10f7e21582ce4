{"code":"import { createSimpleExpression, createCompoundExpression } from '../ast';\r\nimport { advancePositionWithClone, isSimpleIdentifier, parseJS, walkJS } from '../utils';\r\nimport { globalsWhitelist } from '@vue/shared';\r\nexport const transformExpression = (node, context) => {\r\n    if (node.type === 5 /* INTERPOLATION */) {\r\n        node.content = processExpression(node.content, context);\r\n    }\r\n    else if (node.type === 1 /* ELEMENT */) {\r\n        // handle directives on element\r\n        for (let i = 0; i < node.props.length; i++) {\r\n            const dir = node.props[i];\r\n            // do not process for v-on & v-for since they are special handled\r\n            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {\r\n                const exp = dir.exp;\r\n                const arg = dir.arg;\r\n                // do not process exp if this is v-on:arg - we need special handling\r\n                // for wrapping inline statements.\r\n                if (exp && !(dir.name === 'on' && arg)) {\r\n                    dir.exp = processExpression(exp, context, \r\n                    // slot args must be processed as function params\r\n                    dir.name === 'slot');\r\n                }\r\n                if (arg && !arg.isStatic) {\r\n                    dir.arg = processExpression(arg, context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n// Important: since this function uses Node.js only dependencies, it should\r\n// always be used with a leading !__BROWSER__ check so that it can be\r\n// tree-shaken from the browser build.\r\nexport function processExpression(node, context, \r\n// some expressions like v-slot props & v-for aliases should be parsed as\r\n// function params\r\nasParams = false) {\r\n    if (!context.prefixIdentifiers) {\r\n        return node;\r\n    }\r\n    // fast path if expression is a simple identifier.\r\n    if (isSimpleIdentifier(node.content)) {\r\n        if (!asParams && !context.identifiers[node.content]) {\r\n            node.content = `_ctx.${node.content}`;\r\n        }\r\n        return node;\r\n    }\r\n    let ast;\r\n    // if the expression is supposed to be used in a function params position\r\n    // we need to parse it differently.\r\n    const source = `(${node.content})${asParams ? `=>{}` : ``}`;\r\n    try {\r\n        ast = parseJS(source, { ranges: true });\r\n    }\r\n    catch (e) {\r\n        context.onError(e);\r\n        return node;\r\n    }\r\n    const ids = [];\r\n    const knownIds = Object.create(context.identifiers);\r\n    // walk the AST and look for identifiers that need to be prefixed with `_ctx.`.\r\n    walkJS(ast, {\r\n        enter(node, parent) {\r\n            if (node.type === 'Identifier') {\r\n                if (!ids.includes(node)) {\r\n                    if (!knownIds[node.name] && shouldPrefix(node, parent)) {\r\n                        if (isPropertyShorthand(node, parent)) {\r\n                            // property shorthand like { foo }, we need to add the key since we\r\n                            // rewrite the value\r\n                            node.prefix = `${node.name}: `;\r\n                        }\r\n                        node.name = `_ctx.${node.name}`;\r\n                        ids.push(node);\r\n                    }\r\n                    else if (!isStaticPropertyKey(node, parent)) {\r\n                        // also generate sub-expressions for other identifiers for better\r\n                        // source map support. (except for property keys which are static)\r\n                        ids.push(node);\r\n                    }\r\n                }\r\n            }\r\n            else if (isFunction(node)) {\r\n                // walk function expressions and add its arguments to known identifiers\r\n                // so that we don't prefix them\r\n                node.params.forEach(p => walkJS(p, {\r\n                    enter(child, parent) {\r\n                        if (child.type === 'Identifier' &&\r\n                            // do not record as scope variable if is a destructured key\r\n                            !isStaticPropertyKey(child, parent) &&\r\n                            // do not record if this is a default value\r\n                            // assignment of a destructured variable\r\n                            !(parent &&\r\n                                parent.type === 'AssignmentPattern' &&\r\n                                parent.right === child)) {\r\n                            const { name } = child;\r\n                            if (node._scopeIds &&\r\n                                node._scopeIds.has(name)) {\r\n                                return;\r\n                            }\r\n                            if (name in knownIds) {\r\n                                knownIds[name]++;\r\n                            }\r\n                            else {\r\n                                knownIds[name] = 1;\r\n                            }\r\n                            ;\r\n                            (node._scopeIds ||\r\n                                (node._scopeIds = new Set())).add(name);\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n        },\r\n        leave(node) {\r\n            if (node !== ast.body[0].expression && node._scopeIds) {\r\n                node._scopeIds.forEach((id) => {\r\n                    knownIds[id]--;\r\n                    if (knownIds[id] === 0) {\r\n                        delete knownIds[id];\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    // We break up the compound expression into an array of strings and sub\r\n    // expressions (for identifiers that have been prefixed). In codegen, if\r\n    // an ExpressionNode has the `.children` property, it will be used instead of\r\n    // `.content`.\r\n    const full = node.content;\r\n    const children = [];\r\n    ids.sort((a, b) => a.start - b.start);\r\n    ids.forEach((id, i) => {\r\n        // range is offset by -1 due to the wrapping parens when parsed\r\n        const start = id.start - 1;\r\n        const end = id.end - 1;\r\n        const last = ids[i - 1];\r\n        const leadingText = full.slice(last ? last.end - 1 : 0, start);\r\n        if (leadingText.length || id.prefix) {\r\n            children.push(leadingText + (id.prefix || ``));\r\n        }\r\n        const source = full.slice(start, end);\r\n        children.push(createSimpleExpression(id.name, false, {\r\n            source,\r\n            start: advancePositionWithClone(node.loc.start, source, start),\r\n            end: advancePositionWithClone(node.loc.start, source, end)\r\n        }));\r\n        if (i === ids.length - 1 && end < full.length) {\r\n            children.push(full.slice(end));\r\n        }\r\n    });\r\n    let ret;\r\n    if (children.length) {\r\n        ret = createCompoundExpression(children);\r\n    }\r\n    else {\r\n        ret = node;\r\n    }\r\n    ret.identifiers = Object.keys(knownIds);\r\n    return ret;\r\n}\r\nconst isFunction = (node) => /Function(Expression|Declaration)$/.test(node.type);\r\nconst isPropertyKey = (node, parent) => parent &&\r\n    parent.type === 'Property' &&\r\n    parent.key === node &&\r\n    !parent.computed;\r\nconst isPropertyShorthand = (node, parent) => isPropertyKey(node, parent) && parent.value === node;\r\nconst isStaticPropertyKey = (node, parent) => isPropertyKey(node, parent) && parent.value !== node;\r\nfunction shouldPrefix(identifier, parent) {\r\n    if (!(isFunction(parent) &&\r\n        // not id of a FunctionDeclaration\r\n        (parent.id === identifier ||\r\n            // not a params of a function\r\n            parent.params.includes(identifier))) &&\r\n        // not a key of Property\r\n        !isStaticPropertyKey(identifier, parent) &&\r\n        // not a property of a MemberExpression\r\n        !(parent.type === 'MemberExpression' &&\r\n            parent.property === identifier &&\r\n            !parent.computed) &&\r\n        // not in an Array destructure pattern\r\n        !(parent.type === 'ArrayPattern') &&\r\n        // skip whitelisted globals\r\n        !globalsWhitelist.has(identifier.name) &&\r\n        // special case for webpack compilation\r\n        identifier.name !== `require` &&\r\n        // is a special keyword but parsed as identifier\r\n        identifier.name !== `arguments`) {\r\n        return true;\r\n    }\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transform.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/ast.ts","/Users/apple/Desktop/vue3/vue-next/node_modules/@types/estree/index.d.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/utils.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts"]}
