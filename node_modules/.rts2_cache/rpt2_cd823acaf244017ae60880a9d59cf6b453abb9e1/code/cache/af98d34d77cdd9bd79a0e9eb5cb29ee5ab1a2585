{"code":"import { readonly, toRaw, lock, unlock } from '@vue/reactivity';\r\nimport { EMPTY_OBJ, camelize, hyphenate, capitalize, isString, isFunction, isArray, isObject, isReservedProp, hasOwn, toTypeString } from '@vue/shared';\r\nimport { warn } from './warning';\r\n// resolve raw VNode data.\r\n// - filter out reserved keys (key, ref, slots)\r\n// - extract class and style into $attrs (to be merged onto child\r\n//   component root)\r\n// - for the rest:\r\n//   - if has declared props: put declared ones in `props`, the rest in `attrs`\r\n//   - else: everything goes in `props`.\r\nexport function resolveProps(instance, rawProps, _options) {\r\n    const hasDeclaredProps = _options != null;\r\n    const options = normalizePropsOptions(_options);\r\n    if (!rawProps && !hasDeclaredProps) {\r\n        return;\r\n    }\r\n    const props = {};\r\n    let attrs = void 0;\r\n    // update the instance propsProxy (passed to setup()) to trigger potential\r\n    // changes\r\n    const propsProxy = instance.propsProxy;\r\n    const setProp = propsProxy\r\n        ? (key, val) => {\r\n            props[key] = val;\r\n            propsProxy[key] = val;\r\n        }\r\n        : (key, val) => {\r\n            props[key] = val;\r\n        };\r\n    // allow mutation of propsProxy (which is readonly by default)\r\n    unlock();\r\n    if (rawProps != null) {\r\n        for (const key in rawProps) {\r\n            // key, ref are reserved\r\n            if (isReservedProp(key))\r\n                continue;\r\n            // any non-declared data are put into a separate `attrs` object\r\n            // for spreading\r\n            if (hasDeclaredProps && !hasOwn(options, key)) {\r\n                ;\r\n                (attrs || (attrs = {}))[key] = rawProps[key];\r\n            }\r\n            else {\r\n                setProp(key, rawProps[key]);\r\n            }\r\n        }\r\n    }\r\n    // set default values, cast booleans & run validators\r\n    if (hasDeclaredProps) {\r\n        for (const key in options) {\r\n            let opt = options[key];\r\n            if (opt == null)\r\n                continue;\r\n            const isAbsent = !hasOwn(props, key);\r\n            const hasDefault = hasOwn(opt, 'default');\r\n            const currentValue = props[key];\r\n            // default values\r\n            if (hasDefault && currentValue === undefined) {\r\n                const defaultValue = opt.default;\r\n                setProp(key, isFunction(defaultValue) ? defaultValue() : defaultValue);\r\n            }\r\n            // boolean casting\r\n            if (opt[\"1\" /* shouldCast */]) {\r\n                if (isAbsent && !hasDefault) {\r\n                    setProp(key, false);\r\n                }\r\n                else if (opt[\"2\" /* shouldCastTrue */] &&\r\n                    (currentValue === '' || currentValue === hyphenate(key))) {\r\n                    setProp(key, true);\r\n                }\r\n            }\r\n            // runtime validation\r\n            if (__DEV__ && rawProps) {\r\n                validateProp(key, toRaw(rawProps[key]), opt, isAbsent);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // if component has no declared props, $attrs === $props\r\n        attrs = props;\r\n    }\r\n    // in case of dynamic props, check if we need to delete keys from\r\n    // the props proxy\r\n    const { patchFlag } = instance.vnode;\r\n    if (propsProxy !== null &&\r\n        (patchFlag === 0 || patchFlag & 16 /* FULL_PROPS */)) {\r\n        const rawInitialProps = toRaw(propsProxy);\r\n        for (const key in rawInitialProps) {\r\n            if (!hasOwn(props, key)) {\r\n                delete propsProxy[key];\r\n            }\r\n        }\r\n    }\r\n    // lock readonly\r\n    lock();\r\n    instance.props = __DEV__ ? readonly(props) : props;\r\n    instance.attrs = options\r\n        ? __DEV__ && attrs != null\r\n            ? readonly(attrs)\r\n            : attrs\r\n        : instance.props;\r\n}\r\nconst normalizationMap = new WeakMap();\r\nfunction normalizePropsOptions(raw) {\r\n    if (!raw) {\r\n        return null;\r\n    }\r\n    if (normalizationMap.has(raw)) {\r\n        return normalizationMap.get(raw);\r\n    }\r\n    const normalized = {};\r\n    normalizationMap.set(raw, normalized);\r\n    if (isArray(raw)) {\r\n        for (let i = 0; i < raw.length; i++) {\r\n            if (__DEV__ && !isString(raw[i])) {\r\n                warn(`props must be strings when using array syntax.`, raw[i]);\r\n            }\r\n            const normalizedKey = camelize(raw[i]);\r\n            if (normalizedKey[0] !== '$') {\r\n                normalized[normalizedKey] = EMPTY_OBJ;\r\n            }\r\n            else if (__DEV__) {\r\n                warn(`Invalid prop name: \"${normalizedKey}\" is a reserved property.`);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (__DEV__ && !isObject(raw)) {\r\n            warn(`invalid props options`, raw);\r\n        }\r\n        for (const key in raw) {\r\n            const normalizedKey = camelize(key);\r\n            if (normalizedKey[0] !== '$') {\r\n                const opt = raw[key];\r\n                const prop = (normalized[normalizedKey] =\r\n                    isArray(opt) || isFunction(opt) ? { type: opt } : opt);\r\n                if (prop != null) {\r\n                    const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n                    const stringIndex = getTypeIndex(String, prop.type);\r\n                    prop[\"1\" /* shouldCast */] = booleanIndex > -1;\r\n                    prop[\"2\" /* shouldCastTrue */] = booleanIndex < stringIndex;\r\n                }\r\n            }\r\n            else if (__DEV__) {\r\n                warn(`Invalid prop name: \"${normalizedKey}\" is a reserved property.`);\r\n            }\r\n        }\r\n    }\r\n    return normalized;\r\n}\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor) {\r\n    const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\r\n    return match ? match[1] : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (isArray(expectedTypes)) {\r\n        for (let i = 0, len = expectedTypes.length; i < len; i++) {\r\n            if (isSameType(expectedTypes[i], type)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    return -1;\r\n}\r\nfunction validateProp(name, value, prop, isAbsent) {\r\n    const { type, required, validator } = prop;\r\n    // required!\r\n    if (required && isAbsent) {\r\n        warn('Missing required prop: \"' + name + '\"');\r\n        return;\r\n    }\r\n    // missing but optional\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    // type check\r\n    if (type != null && type !== true) {\r\n        let isValid = false;\r\n        const types = isArray(type) ? type : [type];\r\n        const expectedTypes = [];\r\n        // value is valid as long as one of the specified types match\r\n        for (let i = 0; i < types.length && !isValid; i++) {\r\n            const { valid, expectedType } = assertType(value, types[i]);\r\n            expectedTypes.push(expectedType || '');\r\n            isValid = valid;\r\n        }\r\n        if (!isValid) {\r\n            warn(getInvalidTypeMessage(name, value, expectedTypes));\r\n            return;\r\n        }\r\n    }\r\n    // custom validator\r\n    if (validator && !validator(value)) {\r\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".');\r\n    }\r\n}\r\nconst simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\r\nfunction assertType(value, type) {\r\n    let valid;\r\n    const expectedType = getType(type);\r\n    if (simpleCheckRE.test(expectedType)) {\r\n        const t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === 'object') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === 'Object') {\r\n        valid = toRawType(value) === 'Object';\r\n    }\r\n    else if (expectedType === 'Array') {\r\n        valid = isArray(value);\r\n    }\r\n    else {\r\n        valid = value instanceof type;\r\n    }\r\n    return {\r\n        valid,\r\n        expectedType\r\n    };\r\n}\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    let message = `Invalid prop: type check failed for prop \"${name}\".` +\r\n        ` Expected ${expectedTypes.map(capitalize).join(', ')}`;\r\n    const expectedType = expectedTypes[0];\r\n    const receivedType = toRawType(value);\r\n    const expectedValue = styleValue(value, expectedType);\r\n    const receivedValue = styleValue(value, receivedType);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        !isBoolean(expectedType, receivedType)) {\r\n        message += ` with value ${expectedValue}`;\r\n    }\r\n    message += `, got ${receivedType} `;\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += `with value ${receivedValue}.`;\r\n    }\r\n    return message;\r\n}\r\nfunction styleValue(value, type) {\r\n    if (type === 'String') {\r\n        return `\"${value}\"`;\r\n    }\r\n    else if (type === 'Number') {\r\n        return `${Number(value)}`;\r\n    }\r\n    else {\r\n        return `${value}`;\r\n    }\r\n}\r\nfunction toRawType(value) {\r\n    return toTypeString(value).slice(8, -1);\r\n}\r\nfunction isExplicable(type) {\r\n    const explicitTypes = ['string', 'number', 'boolean'];\r\n    return explicitTypes.some(elem => type.toLowerCase() === elem);\r\n}\r\nfunction isBoolean(...args) {\r\n    return args.some(elem => elem.toLowerCase() === 'boolean');\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/warning.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/component.ts"]}
