{"code":"import { Text, Fragment, Comment, Portal, normalizeVNode, Suspense, createVNode } from './vnode';\r\nimport { createComponentInstance, setupStatefulComponent, handleSetupResult } from './component';\r\nimport { renderComponentRoot, shouldUpdateComponent } from './componentRenderUtils';\r\nimport { isString, EMPTY_OBJ, EMPTY_ARR, isReservedProp, isFunction, isArray } from '@vue/shared';\r\nimport { queueJob, queuePostFlushCb, flushPostFlushCbs } from './scheduler';\r\nimport { effect, stop, isRef, toRaw } from '@vue/reactivity';\r\nimport { resolveProps } from './componentProps';\r\nimport { resolveSlots } from './componentSlots';\r\nimport { pushWarningContext, popWarningContext, warn } from './warning';\r\nimport { invokeDirectiveHook } from './directives';\r\nimport { createAppAPI } from './apiApp';\r\nimport { createSuspenseBoundary, normalizeSuspenseChildren } from './suspense';\r\nimport { handleError } from './errorHandling';\r\nconst prodEffectOptions = {\r\n    scheduler: queueJob\r\n};\r\nfunction createDevEffectOptions(instance) {\r\n    return {\r\n        scheduler: queueJob,\r\n        onTrack: instance.rtc ? e => invokeHooks(instance.rtc, e) : void 0,\r\n        onTrigger: instance.rtg ? e => invokeHooks(instance.rtg, e) : void 0\r\n    };\r\n}\r\nfunction isSameType(n1, n2) {\r\n    return n1.type === n2.type && n1.key === n2.key;\r\n}\r\nfunction invokeHooks(hooks, arg) {\r\n    for (let i = 0; i < hooks.length; i++) {\r\n        hooks[i](arg);\r\n    }\r\n}\r\nexport function queuePostRenderEffect(fn, suspense) {\r\n    if (suspense !== null && !suspense.isResolved) {\r\n        if (isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nexport function createRenderer(options) {\r\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, querySelector: hostQuerySelector } = options;\r\n    function patch(n1, // null means this is a mount\r\n    n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) {\r\n        // patching & not same type, unmount old tree\r\n        if (n1 != null && !isSameType(n1, n2)) {\r\n            anchor = getNextHostNode(n1);\r\n            unmount(n1, parentComponent, parentSuspense, true);\r\n            n1 = null;\r\n        }\r\n        const { type, shapeFlag } = n2;\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container, anchor);\r\n                break;\r\n            case Comment:\r\n                processCommentNode(n1, n2, container, anchor);\r\n                break;\r\n            case Fragment:\r\n                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                break;\r\n            case Portal:\r\n                processPortal(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                break;\r\n            case Suspense:\r\n                if (__FEATURE_SUSPENSE__) {\r\n                    processSuspense(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else if (__DEV__) {\r\n                    warn(`Suspense is not enabled in the version of Vue you are using.`);\r\n                }\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else if (__DEV__) {\r\n                    warn('Invalid HostVNode type:', n2.type, `(${typeof n2.type})`);\r\n                }\r\n        }\r\n    }\r\n    function processText(n1, n2, container, anchor) {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\r\n        }\r\n        else {\r\n            const el = (n2.el = n1.el);\r\n            if (n2.children !== n1.children) {\r\n                hostSetText(el, n2.children);\r\n            }\r\n        }\r\n    }\r\n    function processCommentNode(n1, n2, container, anchor) {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);\r\n        }\r\n        else {\r\n            // there's no support for dynamic comments\r\n            n2.el = n1.el;\r\n        }\r\n    }\r\n    function processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {\r\n        if (n1 == null) {\r\n            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        else {\r\n            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        if (n2.ref !== null && parentComponent !== null) {\r\n            setRef(n2.ref, n1 && n1.ref, parentComponent, n2.el);\r\n        }\r\n    }\r\n    function mountElement(vnode, container, anchor, parentComponent, parentSuspense, isSVG) {\r\n        const tag = vnode.type;\r\n        isSVG = isSVG || tag === 'svg';\r\n        const el = (vnode.el = hostCreateElement(tag, isSVG));\r\n        const { props, shapeFlag } = vnode;\r\n        if (props != null) {\r\n            for (const key in props) {\r\n                if (isReservedProp(key))\r\n                    continue;\r\n                hostPatchProp(el, key, props[key], null, isSVG);\r\n            }\r\n            if (props.vnodeBeforeMount != null) {\r\n                invokeDirectiveHook(props.vnodeBeforeMount, parentComponent, vnode);\r\n            }\r\n        }\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            hostSetElementText(el, vnode.children);\r\n        }\r\n        else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        hostInsert(el, container, anchor);\r\n        if (props != null && props.vnodeMounted != null) {\r\n            queuePostRenderEffect(() => {\r\n                invokeDirectiveHook(props.vnodeMounted, parentComponent, vnode);\r\n            }, parentSuspense);\r\n        }\r\n    }\r\n    function mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, start = 0) {\r\n        for (let i = start; i < children.length; i++) {\r\n            const child = (children[i] = normalizeVNode(children[i]));\r\n            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG);\r\n        }\r\n    }\r\n    function patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized) {\r\n        const el = (n2.el = n1.el);\r\n        const { patchFlag, dynamicChildren } = n2;\r\n        const oldProps = (n1 && n1.props) || EMPTY_OBJ;\r\n        const newProps = n2.props || EMPTY_OBJ;\r\n        if (newProps.vnodeBeforeUpdate != null) {\r\n            invokeDirectiveHook(newProps.vnodeBeforeUpdate, parentComponent, n2, n1);\r\n        }\r\n        if (patchFlag > 0) {\r\n            // the presence of a patchFlag means this element's render code was\r\n            // generated by the compiler and can take the fast path.\r\n            // in this path old node and new node are guaranteed to have the same shape\r\n            // (i.e. at the exact same position in the source template)\r\n            if (patchFlag & 16 /* FULL_PROPS */) {\r\n                // element props contain dynamic keys, full diff needed\r\n                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            else {\r\n                // class\r\n                // this flag is matched when the element has dynamic class bindings.\r\n                if (patchFlag & 2 /* CLASS */) {\r\n                    if (oldProps.class !== newProps.class) {\r\n                        hostPatchProp(el, 'class', newProps.class, null, isSVG);\r\n                    }\r\n                }\r\n                // style\r\n                // this flag is matched when the element has dynamic style bindings\r\n                if (patchFlag & 4 /* STYLE */) {\r\n                    hostPatchProp(el, 'style', newProps.style, oldProps.style, isSVG);\r\n                }\r\n                // props\r\n                // This flag is matched when the element has dynamic prop/attr bindings\r\n                // other than class and style. The keys of dynamic prop/attrs are saved for\r\n                // faster iteration.\r\n                // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\r\n                // bail out and go through a full diff because we need to unset the old key\r\n                if (patchFlag & 8 /* PROPS */) {\r\n                    // if the flag is present then dynamicProps must be non-null\r\n                    const propsToUpdate = n2.dynamicProps;\r\n                    for (let i = 0; i < propsToUpdate.length; i++) {\r\n                        const key = propsToUpdate[i];\r\n                        const prev = oldProps[key];\r\n                        const next = newProps[key];\r\n                        if (prev !== next) {\r\n                            hostPatchProp(el, key, next, prev, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // text\r\n            // This flag is matched when the element has only dynamic text children.\r\n            // this flag is terminal (i.e. skips children diffing).\r\n            if (patchFlag & 1 /* TEXT */) {\r\n                if (n1.children !== n2.children) {\r\n                    hostSetElementText(el, n2.children);\r\n                }\r\n                return; // terminal\r\n            }\r\n        }\r\n        else if (!optimized) {\r\n            // unoptimized, full diff\r\n            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        if (dynamicChildren != null) {\r\n            // children fast path\r\n            const oldDynamicChildren = n1.dynamicChildren;\r\n            for (let i = 0; i < dynamicChildren.length; i++) {\r\n                patch(oldDynamicChildren[i], dynamicChildren[i], el, null, parentComponent, parentSuspense, isSVG, true);\r\n            }\r\n        }\r\n        else if (!optimized) {\r\n            // full diff\r\n            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        if (newProps.vnodeUpdated != null) {\r\n            queuePostRenderEffect(() => {\r\n                invokeDirectiveHook(newProps.vnodeUpdated, parentComponent, n2, n1);\r\n            }, parentSuspense);\r\n        }\r\n    }\r\n    function patchProps(el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) {\r\n        if (oldProps !== newProps) {\r\n            for (const key in newProps) {\r\n                if (isReservedProp(key))\r\n                    continue;\r\n                const next = newProps[key];\r\n                const prev = oldProps[key];\r\n                if (next !== prev) {\r\n                    hostPatchProp(el, key, next, prev, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                }\r\n            }\r\n            if (oldProps !== EMPTY_OBJ) {\r\n                for (const key in oldProps) {\r\n                    if (isReservedProp(key))\r\n                        continue;\r\n                    if (!(key in newProps)) {\r\n                        hostPatchProp(el, key, null, null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {\r\n        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateComment(''));\r\n        const fragmentEndAnchor = (n2.anchor = n1\r\n            ? n1.anchor\r\n            : hostCreateComment(''));\r\n        if (n1 == null) {\r\n            hostInsert(fragmentStartAnchor, container, anchor);\r\n            hostInsert(fragmentEndAnchor, container, anchor);\r\n            // a fragment can only have array children\r\n            // since they are either generated by the compiler, or implicitly created\r\n            // from arrays.\r\n            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        else {\r\n            patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n    }\r\n    function processPortal(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {\r\n        const targetSelector = n2.props && n2.props.target;\r\n        const { patchFlag, shapeFlag, children } = n2;\r\n        if (n1 == null) {\r\n            const target = (n2.target = isString(targetSelector)\r\n                ? hostQuerySelector(targetSelector)\r\n                : null);\r\n            if (target != null) {\r\n                if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                    hostSetElementText(target, children);\r\n                }\r\n                else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(children, target, null, parentComponent, parentSuspense, isSVG);\r\n                }\r\n            }\r\n            else if (__DEV__) {\r\n                warn('Invalid Portal target on mount:', target, `(${typeof target})`);\r\n            }\r\n        }\r\n        else {\r\n            // update content\r\n            const target = (n2.target = n1.target);\r\n            if (patchFlag === 1 /* TEXT */) {\r\n                hostSetElementText(target, children);\r\n            }\r\n            else if (!optimized) {\r\n                patchChildren(n1, n2, target, null, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            // target changed\r\n            if (targetSelector !== (n1.props && n1.props.target)) {\r\n                const nextTarget = (n2.target = isString(targetSelector)\r\n                    ? hostQuerySelector(targetSelector)\r\n                    : null);\r\n                if (nextTarget != null) {\r\n                    // move content\r\n                    if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                        hostSetElementText(target, '');\r\n                        hostSetElementText(nextTarget, children);\r\n                    }\r\n                    else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                        for (let i = 0; i < children.length; i++) {\r\n                            move(children[i], nextTarget, null);\r\n                        }\r\n                    }\r\n                }\r\n                else if (__DEV__) {\r\n                    warn('Invalid Portal target on update:', target, `(${typeof target})`);\r\n                }\r\n            }\r\n        }\r\n        // insert an empty node as the placeholder for the portal\r\n        processCommentNode(n1, n2, container, anchor);\r\n    }\r\n    function processSuspense(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {\r\n        if (n1 == null) {\r\n            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        else {\r\n            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized);\r\n        }\r\n    }\r\n    function mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {\r\n        const hiddenContainer = hostCreateElement('div');\r\n        const suspense = (n2.suspense = createSuspenseBoundary(n2, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized));\r\n        const { content, fallback } = normalizeSuspenseChildren(n2);\r\n        suspense.subTree = content;\r\n        suspense.fallbackTree = fallback;\r\n        // start mounting the content subtree in an off-dom container\r\n        patch(null, content, hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\r\n        // now check if we have encountered any async deps\r\n        if (suspense.deps > 0) {\r\n            // mount the fallback tree\r\n            patch(null, fallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n            isSVG, optimized);\r\n            n2.el = fallback.el;\r\n        }\r\n        else {\r\n            // Suspense has no async deps. Just resolve.\r\n            resolveSuspense(suspense);\r\n        }\r\n    }\r\n    function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized) {\r\n        const suspense = (n2.suspense = n1.suspense);\r\n        suspense.vnode = n2;\r\n        const { content, fallback } = normalizeSuspenseChildren(n2);\r\n        const oldSubTree = suspense.subTree;\r\n        const oldFallbackTree = suspense.fallbackTree;\r\n        if (!suspense.isResolved) {\r\n            patch(oldSubTree, content, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\r\n            if (suspense.deps > 0) {\r\n                // still pending. patch the fallback tree.\r\n                patch(oldFallbackTree, fallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG, optimized);\r\n                n2.el = fallback.el;\r\n            }\r\n            // If deps somehow becomes 0 after the patch it means the patch caused an\r\n            // async dep component to unmount and removed its dep. It will cause the\r\n            // suspense to resolve and we don't need to do anything here.\r\n        }\r\n        else {\r\n            // just normal patch inner content as a fragment\r\n            patch(oldSubTree, content, container, anchor, parentComponent, suspense, isSVG, optimized);\r\n            n2.el = content.el;\r\n        }\r\n        suspense.subTree = content;\r\n        suspense.fallbackTree = fallback;\r\n    }\r\n    function resolveSuspense(suspense) {\r\n        if (__DEV__) {\r\n            if (suspense.isResolved) {\r\n                throw new Error(`resolveSuspense() is called on an already resolved suspense boundary.`);\r\n            }\r\n            if (suspense.isUnmounted) {\r\n                throw new Error(`resolveSuspense() is called on an already unmounted suspense boundary.`);\r\n            }\r\n        }\r\n        const { vnode, subTree, fallbackTree, effects, parentComponent, container } = suspense;\r\n        // this is initial anchor on mount\r\n        let { anchor } = suspense;\r\n        // unmount fallback tree\r\n        if (fallbackTree.el) {\r\n            // if the fallback tree was mounted, it may have been moved\r\n            // as part of a parent suspense. get the latest anchor for insertion\r\n            anchor = getNextHostNode(fallbackTree);\r\n            unmount(fallbackTree, parentComponent, suspense, true);\r\n        }\r\n        // move content from off-dom container to actual container\r\n        move(subTree, container, anchor);\r\n        const el = (vnode.el = subTree.el);\r\n        // suspense as the root node of a component...\r\n        if (parentComponent && parentComponent.subTree === vnode) {\r\n            parentComponent.vnode.el = el;\r\n            updateHOCHostEl(parentComponent, el);\r\n        }\r\n        // check if there is a pending parent suspense\r\n        let parent = suspense.parent;\r\n        let hasUnresolvedAncestor = false;\r\n        while (parent) {\r\n            if (!parent.isResolved) {\r\n                // found a pending parent suspense, merge buffered post jobs\r\n                // into that parent\r\n                parent.effects.push(...effects);\r\n                hasUnresolvedAncestor = true;\r\n                break;\r\n            }\r\n            parent = parent.parent;\r\n        }\r\n        // no pending parent suspense, flush all jobs\r\n        if (!hasUnresolvedAncestor) {\r\n            queuePostFlushCb(effects);\r\n        }\r\n        suspense.isResolved = true;\r\n        // invoke @resolve event\r\n        const onResolve = vnode.props && vnode.props.onResolve;\r\n        if (isFunction(onResolve)) {\r\n            onResolve();\r\n        }\r\n    }\r\n    function restartSuspense(suspense) {\r\n        suspense.isResolved = false;\r\n        const { vnode, subTree, fallbackTree, parentComponent, container, hiddenContainer, isSVG, optimized } = suspense;\r\n        // move content tree back to the off-dom container\r\n        const anchor = getNextHostNode(subTree);\r\n        move(subTree, hiddenContainer, null);\r\n        // remount the fallback tree\r\n        patch(null, fallbackTree, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n        isSVG, optimized);\r\n        const el = (vnode.el = fallbackTree.el);\r\n        // suspense as the root node of a component...\r\n        if (parentComponent && parentComponent.subTree === vnode) {\r\n            parentComponent.vnode.el = el;\r\n            updateHOCHostEl(parentComponent, el);\r\n        }\r\n        // invoke @suspense event\r\n        const onSuspense = vnode.props && vnode.props.onSuspense;\r\n        if (isFunction(onSuspense)) {\r\n            onSuspense();\r\n        }\r\n    }\r\n    function processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {\r\n        if (n1 == null) {\r\n            mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        else {\r\n            const instance = (n2.component = n1.component);\r\n            if (shouldUpdateComponent(n1, n2, optimized)) {\r\n                if (__FEATURE_SUSPENSE__ &&\r\n                    instance.asyncDep &&\r\n                    !instance.asyncResolved) {\r\n                    // async & still pending - just update props and slots\r\n                    // since the component's reactive effect for render isn't set-up yet\r\n                    if (__DEV__) {\r\n                        pushWarningContext(n2);\r\n                    }\r\n                    updateComponentPreRender(instance, n2);\r\n                    if (__DEV__) {\r\n                        popWarningContext();\r\n                    }\r\n                    return;\r\n                }\r\n                else {\r\n                    // normal update\r\n                    instance.next = n2;\r\n                    // instance.update is the reactive effect runner.\r\n                    instance.update();\r\n                }\r\n            }\r\n            else {\r\n                // no update needed. just copy over properties\r\n                n2.component = n1.component;\r\n                n2.el = n1.el;\r\n            }\r\n        }\r\n        if (n2.ref !== null && parentComponent !== null) {\r\n            setRef(n2.ref, n1 && n1.ref, parentComponent, n2.component.renderProxy);\r\n        }\r\n    }\r\n    function mountComponent(initialVNode, container, anchor, parentComponent, parentSuspense, isSVG) {\r\n        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent));\r\n        if (__DEV__) {\r\n            pushWarningContext(initialVNode);\r\n        }\r\n        // resolve props and slots for setup context\r\n        const propsOptions = initialVNode.type.props;\r\n        resolveProps(instance, initialVNode.props, propsOptions);\r\n        resolveSlots(instance, initialVNode.children);\r\n        // setup stateful logic\r\n        if (initialVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            setupStatefulComponent(instance, parentSuspense);\r\n        }\r\n        // setup() is async. This component relies on async logic to be resolved\r\n        // before proceeding\r\n        if (__FEATURE_SUSPENSE__ && instance.asyncDep) {\r\n            if (!parentSuspense) {\r\n                // TODO handle this properly\r\n                throw new Error('Async component without a suspense boundary!');\r\n            }\r\n            // parent suspense already resolved, need to re-suspense\r\n            // use queueJob so it's handled synchronously after patching the current\r\n            // suspense tree\r\n            if (parentSuspense.isResolved) {\r\n                queueJob(() => {\r\n                    restartSuspense(parentSuspense);\r\n                });\r\n            }\r\n            parentSuspense.deps++;\r\n            instance.asyncDep\r\n                .catch(err => {\r\n                handleError(err, instance, 0 /* SETUP_FUNCTION */);\r\n            })\r\n                .then(asyncSetupResult => {\r\n                // component may be unmounted before resolve\r\n                if (!instance.isUnmounted && !parentSuspense.isUnmounted) {\r\n                    retryAsyncComponent(instance, asyncSetupResult, parentSuspense, isSVG);\r\n                }\r\n            });\r\n            // give it a placeholder\r\n            const placeholder = (instance.subTree = createVNode(Comment));\r\n            processCommentNode(null, placeholder, container, anchor);\r\n            initialVNode.el = placeholder.el;\r\n            return;\r\n        }\r\n        setupRenderEffect(instance, parentSuspense, initialVNode, container, anchor, isSVG);\r\n        if (__DEV__) {\r\n            popWarningContext();\r\n        }\r\n    }\r\n    function retryAsyncComponent(instance, asyncSetupResult, parentSuspense, isSVG) {\r\n        parentSuspense.deps--;\r\n        // retry from this component\r\n        instance.asyncResolved = true;\r\n        const { vnode } = instance;\r\n        if (__DEV__) {\r\n            pushWarningContext(vnode);\r\n        }\r\n        handleSetupResult(instance, asyncSetupResult, parentSuspense);\r\n        setupRenderEffect(instance, parentSuspense, vnode, \r\n        // component may have been moved before resolve\r\n        hostParentNode(instance.subTree.el), getNextHostNode(instance.subTree), isSVG);\r\n        updateHOCHostEl(instance, vnode.el);\r\n        if (__DEV__) {\r\n            popWarningContext();\r\n        }\r\n        if (parentSuspense.deps === 0) {\r\n            resolveSuspense(parentSuspense);\r\n        }\r\n    }\r\n    function setupRenderEffect(instance, parentSuspense, initialVNode, container, anchor, isSVG) {\r\n        // create reactive effect for rendering\r\n        let mounted = false;\r\n        instance.update = effect(function componentEffect() {\r\n            if (!mounted) {\r\n                const subTree = (instance.subTree = renderComponentRoot(instance));\r\n                // beforeMount hook\r\n                if (instance.bm !== null) {\r\n                    invokeHooks(instance.bm);\r\n                }\r\n                patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\r\n                initialVNode.el = subTree.el;\r\n                // mounted hook\r\n                if (instance.m !== null) {\r\n                    queuePostRenderEffect(instance.m, parentSuspense);\r\n                }\r\n                mounted = true;\r\n            }\r\n            else {\r\n                // updateComponent\r\n                // This is triggered by mutation of component's own state (next: null)\r\n                // OR parent calling processComponent (next: HostVNode)\r\n                const { next } = instance;\r\n                if (__DEV__) {\r\n                    pushWarningContext(next || instance.vnode);\r\n                }\r\n                if (next !== null) {\r\n                    updateComponentPreRender(instance, next);\r\n                }\r\n                const prevTree = instance.subTree;\r\n                const nextTree = (instance.subTree = renderComponentRoot(instance));\r\n                // beforeUpdate hook\r\n                if (instance.bu !== null) {\r\n                    invokeHooks(instance.bu);\r\n                }\r\n                // reset refs\r\n                // only needed if previous patch had refs\r\n                if (instance.refs !== EMPTY_OBJ) {\r\n                    instance.refs = {};\r\n                }\r\n                patch(prevTree, nextTree, \r\n                // parent may have changed if it's in a portal\r\n                hostParentNode(prevTree.el), \r\n                // anchor may have changed if it's in a fragment\r\n                getNextHostNode(prevTree), instance, parentSuspense, isSVG);\r\n                instance.vnode.el = nextTree.el;\r\n                if (next === null) {\r\n                    // self-triggered update. In case of HOC, update parent component\r\n                    // vnode el. HOC is indicated by parent instance's subTree pointing\r\n                    // to child component's vnode\r\n                    updateHOCHostEl(instance, nextTree.el);\r\n                }\r\n                // updated hook\r\n                if (instance.u !== null) {\r\n                    queuePostRenderEffect(instance.u, parentSuspense);\r\n                }\r\n                if (__DEV__) {\r\n                    popWarningContext();\r\n                }\r\n            }\r\n        }, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions);\r\n    }\r\n    function updateComponentPreRender(instance, nextVNode) {\r\n        nextVNode.component = instance;\r\n        instance.vnode = nextVNode;\r\n        instance.next = null;\r\n        resolveProps(instance, nextVNode.props, nextVNode.type.props);\r\n        resolveSlots(instance, nextVNode.children);\r\n    }\r\n    function updateHOCHostEl({ vnode, parent }, el) {\r\n        while (parent && parent.subTree === vnode) {\r\n            ;\r\n            (vnode = parent.vnode).el = el;\r\n            parent = parent.parent;\r\n        }\r\n    }\r\n    function patchChildren(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) {\r\n        const c1 = n1 && n1.children;\r\n        const prevShapeFlag = n1 ? n1.shapeFlag : 0;\r\n        const c2 = n2.children;\r\n        const { patchFlag, shapeFlag } = n2;\r\n        if (patchFlag === -1 /* BAIL */) {\r\n            optimized = false;\r\n        }\r\n        // fast path\r\n        if (patchFlag > 0) {\r\n            if (patchFlag & 64 /* KEYED_FRAGMENT */) {\r\n                // this could be either fully-keyed or mixed (some keyed some not)\r\n                // presence of patchFlag means children are guaranteed to be arrays\r\n                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                return;\r\n            }\r\n            else if (patchFlag & 128 /* UNKEYED_FRAGMENT */) {\r\n                // unkeyed\r\n                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                return;\r\n            }\r\n        }\r\n        // children has 3 possibilities: text, array or no children.\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            // text children fast path\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                unmountChildren(c1, parentComponent, parentSuspense);\r\n            }\r\n            if (c2 !== c1) {\r\n                hostSetElementText(container, c2);\r\n            }\r\n        }\r\n        else {\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                // prev children was array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    // two arrays, cannot assume anything, do full diff\r\n                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else {\r\n                    // no new children, just unmount old\r\n                    unmountChildren(c1, parentComponent, parentSuspense, true);\r\n                }\r\n            }\r\n            else {\r\n                // prev children was text OR null\r\n                // new children is array OR null\r\n                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                    hostSetElementText(container, '');\r\n                }\r\n                // mount new if array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {\r\n        c1 = c1 || EMPTY_ARR;\r\n        c2 = c2 || EMPTY_ARR;\r\n        const oldLength = c1.length;\r\n        const newLength = c2.length;\r\n        const commonLength = Math.min(oldLength, newLength);\r\n        let i;\r\n        for (i = 0; i < commonLength; i++) {\r\n            const nextChild = (c2[i] = normalizeVNode(c2[i]));\r\n            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        if (oldLength > newLength) {\r\n            // remove old\r\n            unmountChildren(c1, parentComponent, parentSuspense, true, commonLength);\r\n        }\r\n        else {\r\n            // mount new\r\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, commonLength);\r\n        }\r\n    }\r\n    // can be all-keyed or mixed\r\n    function patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {\r\n        let i = 0;\r\n        const l2 = c2.length;\r\n        let e1 = c1.length - 1; // prev ending index\r\n        let e2 = l2 - 1; // next ending index\r\n        // 1. sync from start\r\n        // (a b) c\r\n        // (a b) d e\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[i];\r\n            const n2 = (c2[i] = normalizeVNode(c2[i]));\r\n            if (isSameType(n1, n2)) {\r\n                patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // 2. sync from end\r\n        // a (b c)\r\n        // d e (b c)\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[e1];\r\n            const n2 = (c2[e2] = normalizeVNode(c2[e2]));\r\n            if (isSameType(n1, n2)) {\r\n                patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--;\r\n        }\r\n        // 3. common sequence + mount\r\n        // (a b)\r\n        // (a b) c\r\n        // i = 2, e1 = 1, e2 = 2\r\n        // (a b)\r\n        // c (a b)\r\n        // i = 0, e1 = -1, e2 = 0\r\n        if (i > e1) {\r\n            if (i <= e2) {\r\n                const nextPos = e2 + 1;\r\n                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\r\n                while (i <= e2) {\r\n                    patch(null, (c2[i] = normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // 4. common sequence + unmount\r\n        // (a b) c\r\n        // (a b)\r\n        // i = 2, e1 = 2, e2 = 1\r\n        // a (b c)\r\n        // (b c)\r\n        // i = 0, e1 = 0, e2 = -1\r\n        else if (i > e2) {\r\n            while (i <= e1) {\r\n                unmount(c1[i], parentComponent, parentSuspense, true);\r\n                i++;\r\n            }\r\n        }\r\n        // 5. unknown sequence\r\n        // [i ... e1 + 1]: a b [c d e] f g\r\n        // [i ... e2 + 1]: a b [e d c h] f g\r\n        // i = 2, e1 = 4, e2 = 5\r\n        else {\r\n            const s1 = i; // prev starting index\r\n            const s2 = i; // next starting index\r\n            // 5.1 build key:index map for newChildren\r\n            const keyToNewIndexMap = new Map();\r\n            for (i = s2; i <= e2; i++) {\r\n                const nextChild = (c2[i] = normalizeVNode(c2[i]));\r\n                if (nextChild.key != null) {\r\n                    if (__DEV__ && keyToNewIndexMap.has(nextChild.key)) {\r\n                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\r\n                    }\r\n                    keyToNewIndexMap.set(nextChild.key, i);\r\n                }\r\n            }\r\n            // 5.2 loop through old children left to be patched and try to patch\r\n            // matching nodes & remove nodes that are no longer present\r\n            let j;\r\n            let patched = 0;\r\n            const toBePatched = e2 - s2 + 1;\r\n            let moved = false;\r\n            // used to track whether any node has moved\r\n            let maxNewIndexSoFar = 0;\r\n            // works as Map<newIndex, oldIndex>\r\n            // Note that oldIndex is offset by +1\r\n            // and oldIndex = 0 is a special value indicating the new node has\r\n            // no corresponding old node.\r\n            // used for determining longest stable subsequence\r\n            const newIndexToOldIndexMap = [];\r\n            for (i = 0; i < toBePatched; i++)\r\n                newIndexToOldIndexMap.push(0);\r\n            for (i = s1; i <= e1; i++) {\r\n                const prevChild = c1[i];\r\n                if (patched >= toBePatched) {\r\n                    // all new children have been patched so this can only be a removal\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                    continue;\r\n                }\r\n                let newIndex;\r\n                if (prevChild.key != null) {\r\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                }\r\n                else {\r\n                    // key-less node, try to locate a key-less node of the same type\r\n                    for (j = s2; j <= e2; j++) {\r\n                        if (newIndexToOldIndexMap[j - s2] === 0 &&\r\n                            isSameType(prevChild, c2[j])) {\r\n                            newIndex = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndex === undefined) {\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                }\r\n                else {\r\n                    newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                    if (newIndex >= maxNewIndexSoFar) {\r\n                        maxNewIndexSoFar = newIndex;\r\n                    }\r\n                    else {\r\n                        moved = true;\r\n                    }\r\n                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n                    patched++;\r\n                }\r\n            }\r\n            // 5.3 move and mount\r\n            // generate longest stable subsequence only when nodes have moved\r\n            const increasingNewIndexSequence = moved\r\n                ? getSequence(newIndexToOldIndexMap)\r\n                : EMPTY_ARR;\r\n            j = increasingNewIndexSequence.length - 1;\r\n            // looping backwards so that we can use last patched node as anchor\r\n            for (i = toBePatched - 1; i >= 0; i--) {\r\n                const nextIndex = s2 + i;\r\n                const nextChild = c2[nextIndex];\r\n                const anchor = nextIndex + 1 < l2\r\n                    ? c2[nextIndex + 1].el\r\n                    : parentAnchor;\r\n                if (newIndexToOldIndexMap[i] === 0) {\r\n                    // mount new\r\n                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);\r\n                }\r\n                else if (moved) {\r\n                    // move if:\r\n                    // There is no stable subsequence (e.g. a reverse)\r\n                    // OR current node is not among the stable sequence\r\n                    if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n                        move(nextChild, container, anchor);\r\n                    }\r\n                    else {\r\n                        j--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function move(vnode, container, anchor) {\r\n        if (vnode.component !== null) {\r\n            move(vnode.component.subTree, container, anchor);\r\n            return;\r\n        }\r\n        if (__FEATURE_SUSPENSE__ && vnode.type === Suspense) {\r\n            const suspense = vnode.suspense;\r\n            move(suspense.isResolved ? suspense.subTree : suspense.fallbackTree, container, anchor);\r\n            suspense.container = container;\r\n            return;\r\n        }\r\n        if (vnode.type === Fragment) {\r\n            hostInsert(vnode.el, container, anchor);\r\n            const children = vnode.children;\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, anchor);\r\n            }\r\n            hostInsert(vnode.anchor, container, anchor);\r\n        }\r\n        else {\r\n            hostInsert(vnode.el, container, anchor);\r\n        }\r\n    }\r\n    function unmount(vnode, parentComponent, parentSuspense, doRemove) {\r\n        const { props, ref, type, component, suspense, children, dynamicChildren, shapeFlag, anchor } = vnode;\r\n        // unset ref\r\n        if (ref !== null && parentComponent !== null) {\r\n            setRef(ref, null, parentComponent, null);\r\n        }\r\n        if (component != null) {\r\n            unmountComponent(component, parentSuspense, doRemove);\r\n            return;\r\n        }\r\n        if (__FEATURE_SUSPENSE__ && suspense != null) {\r\n            unmountSuspense(suspense, parentComponent, parentSuspense, doRemove);\r\n            return;\r\n        }\r\n        if (props != null && props.vnodeBeforeUnmount != null) {\r\n            invokeDirectiveHook(props.vnodeBeforeUnmount, parentComponent, vnode);\r\n        }\r\n        const shouldRemoveChildren = type === Fragment && doRemove;\r\n        if (dynamicChildren != null) {\r\n            unmountChildren(dynamicChildren, parentComponent, parentSuspense, shouldRemoveChildren);\r\n        }\r\n        else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            unmountChildren(children, parentComponent, parentSuspense, shouldRemoveChildren);\r\n        }\r\n        if (doRemove) {\r\n            hostRemove(vnode.el);\r\n            if (anchor != null)\r\n                hostRemove(anchor);\r\n        }\r\n        if (props != null && props.vnodeUnmounted != null) {\r\n            queuePostRenderEffect(() => {\r\n                invokeDirectiveHook(props.vnodeUnmounted, parentComponent, vnode);\r\n            }, parentSuspense);\r\n        }\r\n    }\r\n    function unmountComponent(instance, parentSuspense, doRemove) {\r\n        const { bum, effects, update, subTree, um } = instance;\r\n        // beforeUnmount hook\r\n        if (bum !== null) {\r\n            invokeHooks(bum);\r\n        }\r\n        if (effects !== null) {\r\n            for (let i = 0; i < effects.length; i++) {\r\n                stop(effects[i]);\r\n            }\r\n        }\r\n        // update may be null if a component is unmounted before its async\r\n        // setup has resolved.\r\n        if (update !== null) {\r\n            stop(update);\r\n            unmount(subTree, instance, parentSuspense, doRemove);\r\n        }\r\n        // unmounted hook\r\n        if (um !== null) {\r\n            queuePostRenderEffect(um, parentSuspense);\r\n        }\r\n        queuePostFlushCb(() => {\r\n            instance.isUnmounted = true;\r\n        });\r\n        // A component with async dep inside a pending suspense is unmounted before\r\n        // its async dep resolves. This should remove the dep from the suspense, and\r\n        // cause the suspense to resolve immediately if that was the last dep.\r\n        if (__FEATURE_SUSPENSE__ &&\r\n            parentSuspense !== null &&\r\n            !parentSuspense.isResolved &&\r\n            !parentSuspense.isUnmounted &&\r\n            instance.asyncDep !== null &&\r\n            !instance.asyncResolved) {\r\n            parentSuspense.deps--;\r\n            if (parentSuspense.deps === 0) {\r\n                resolveSuspense(parentSuspense);\r\n            }\r\n        }\r\n    }\r\n    function unmountSuspense(suspense, parentComponent, parentSuspense, doRemove) {\r\n        suspense.isUnmounted = true;\r\n        unmount(suspense.subTree, parentComponent, parentSuspense, doRemove);\r\n        if (!suspense.isResolved) {\r\n            unmount(suspense.fallbackTree, parentComponent, parentSuspense, doRemove);\r\n        }\r\n    }\r\n    function unmountChildren(children, parentComponent, parentSuspense, doRemove, start = 0) {\r\n        for (let i = start; i < children.length; i++) {\r\n            unmount(children[i], parentComponent, parentSuspense, doRemove);\r\n        }\r\n    }\r\n    function getNextHostNode({ component, suspense, anchor, el }) {\r\n        if (component !== null) {\r\n            return getNextHostNode(component.subTree);\r\n        }\r\n        if (__FEATURE_SUSPENSE__ && suspense !== null) {\r\n            return getNextHostNode(suspense.isResolved ? suspense.subTree : suspense.fallbackTree);\r\n        }\r\n        return hostNextSibling((anchor || el));\r\n    }\r\n    function setRef(ref, oldRef, parent, value) {\r\n        const refs = parent.refs === EMPTY_OBJ ? (parent.refs = {}) : parent.refs;\r\n        const renderContext = toRaw(parent.renderContext);\r\n        // unset old ref\r\n        if (oldRef !== null && oldRef !== ref) {\r\n            if (isString(oldRef)) {\r\n                refs[oldRef] = null;\r\n                const oldSetupRef = renderContext[oldRef];\r\n                if (isRef(oldSetupRef)) {\r\n                    oldSetupRef.value = null;\r\n                }\r\n            }\r\n            else if (isRef(oldRef)) {\r\n                oldRef.value = null;\r\n            }\r\n        }\r\n        if (isString(ref)) {\r\n            const setupRef = renderContext[ref];\r\n            if (isRef(setupRef)) {\r\n                setupRef.value = value;\r\n            }\r\n            refs[ref] = value;\r\n        }\r\n        else if (isRef(ref)) {\r\n            ref.value = value;\r\n        }\r\n        else if (isFunction(ref)) {\r\n            ref(value, refs);\r\n        }\r\n        else if (__DEV__) {\r\n            warn('Invalid template ref type:', value, `(${typeof value})`);\r\n        }\r\n    }\r\n    function render(vnode, rawContainer) {\r\n        let container = rawContainer;\r\n        if (isString(container)) {\r\n            container = hostQuerySelector(container);\r\n            if (!container) {\r\n                if (__DEV__) {\r\n                    warn(`Failed to locate root container: ` + `querySelector returned null.`);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        if (vnode == null) {\r\n            if (container._vnode) {\r\n                unmount(container._vnode, null, null, true);\r\n            }\r\n        }\r\n        else {\r\n            patch(container._vnode || null, vnode, container);\r\n        }\r\n        flushPostFlushCbs();\r\n        container._vnode = vnode;\r\n    }\r\n    return {\r\n        render,\r\n        createApp: createAppAPI(render)\r\n    };\r\n}\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr) {\r\n    const p = arr.slice();\r\n    const result = [0];\r\n    let i, j, u, v, c;\r\n    const len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        const arrI = arr[i];\r\n        if (arrI !== 0) {\r\n            j = result[result.length - 1];\r\n            if (arr[j] < arrI) {\r\n                p[i] = j;\r\n                result.push(i);\r\n                continue;\r\n            }\r\n            u = 0;\r\n            v = result.length - 1;\r\n            while (u < v) {\r\n                c = ((u + v) / 2) | 0;\r\n                if (arr[result[c]] < arrI) {\r\n                    u = c + 1;\r\n                }\r\n                else {\r\n                    v = c;\r\n                }\r\n            }\r\n            if (arrI < arr[result[u]]) {\r\n                if (u > 0) {\r\n                    p[i] = result[u - 1];\r\n                }\r\n                result[u] = i;\r\n            }\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/vnode.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/component.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentRenderUtils.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/scheduler.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentProps.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentSlots.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/shapeFlags.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/warning.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/directives.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentProxy.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/apiApp.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/suspense.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/errorHandling.ts"]}
