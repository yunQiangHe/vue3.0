{"code":"import { currentInstance, setCurrentInstance } from './component';\r\nimport { callWithAsyncErrorHandling, ErrorTypeStrings } from './errorHandling';\r\nimport { warn } from './warning';\r\nimport { capitalize } from '@vue/shared';\r\nimport { pauseTracking, resumeTracking } from '@vue/reactivity';\r\nfunction injectHook(type, hook, target) {\r\n    if (target) {\r\n        ;\r\n        (target[type] || (target[type] = [])).push((...args) => {\r\n            if (target.isUnmounted) {\r\n                return;\r\n            }\r\n            // disable tracking inside all lifecycle hooks\r\n            // since they can potentially be called inside effects.\r\n            pauseTracking();\r\n            // Set currentInstance during hook invocation.\r\n            // This assumes the hook does not synchronously trigger other hooks, which\r\n            // can only be false when the user does something really funky.\r\n            setCurrentInstance(target);\r\n            const res = callWithAsyncErrorHandling(hook, target, type, args);\r\n            setCurrentInstance(null);\r\n            resumeTracking();\r\n            return res;\r\n        });\r\n    }\r\n    else if (__DEV__) {\r\n        const apiName = `on${capitalize(ErrorTypeStrings[type].replace(/ hook$/, ''))}`;\r\n        warn(`${apiName} is called when there is no active component instance to be ` +\r\n            `associated with. ` +\r\n            `Lifecycle injection APIs can only be used during execution of setup().` +\r\n            (__FEATURE_SUSPENSE__\r\n                ? ` If you are using async setup(), make sure to register lifecycle ` +\r\n                    `hooks before the first await statement.`\r\n                : ``));\r\n    }\r\n}\r\nexport function onBeforeMount(hook, target = currentInstance) {\r\n    injectHook(\"bm\" /* BEFORE_MOUNT */, hook, target);\r\n}\r\nexport function onMounted(hook, target = currentInstance) {\r\n    injectHook(\"m\" /* MOUNTED */, hook, target);\r\n}\r\nexport function onBeforeUpdate(hook, target = currentInstance) {\r\n    injectHook(\"bu\" /* BEFORE_UPDATE */, hook, target);\r\n}\r\nexport function onUpdated(hook, target = currentInstance) {\r\n    injectHook(\"u\" /* UPDATED */, hook, target);\r\n}\r\nexport function onBeforeUnmount(hook, target = currentInstance) {\r\n    injectHook(\"bum\" /* BEFORE_UNMOUNT */, hook, target);\r\n}\r\nexport function onUnmounted(hook, target = currentInstance) {\r\n    injectHook(\"um\" /* UNMOUNTED */, hook, target);\r\n}\r\nexport function onRenderTriggered(hook, target = currentInstance) {\r\n    injectHook(\"rtg\" /* RENDER_TRIGGERED */, hook, target);\r\n}\r\nexport function onRenderTracked(hook, target = currentInstance) {\r\n    injectHook(\"rtc\" /* RENDER_TRACKED */, hook, target);\r\n}\r\nexport function onErrorCaptured(hook, target = currentInstance) {\r\n    injectHook(\"ec\" /* ERROR_CAPTURED */, hook, target);\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/component.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentProxy.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/errorHandling.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/warning.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/index.ts"]}
