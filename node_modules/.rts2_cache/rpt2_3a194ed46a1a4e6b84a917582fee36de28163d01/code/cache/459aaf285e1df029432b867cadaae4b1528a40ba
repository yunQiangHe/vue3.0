{"code":"import { normalizeVNode, createVNode, Comment } from './vnode';\r\nimport { handleError } from './errorHandling';\r\n// mark the current rendering instance for asset resolution (e.g.\r\n// resolveComponent, resolveDirective) during render\r\nexport let currentRenderingInstance = null;\r\nexport function renderComponentRoot(instance) {\r\n    const { type: Component, vnode, renderProxy, props, slots, attrs, emit } = instance;\r\n    let result;\r\n    currentRenderingInstance = instance;\r\n    try {\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            result = normalizeVNode(instance.render.call(renderProxy));\r\n        }\r\n        else {\r\n            // functional\r\n            const render = Component;\r\n            result = normalizeVNode(render.length > 1\r\n                ? render(props, {\r\n                    attrs,\r\n                    slots,\r\n                    emit\r\n                })\r\n                : render(props, null));\r\n        }\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, 1 /* RENDER_FUNCTION */);\r\n        result = createVNode(Comment);\r\n    }\r\n    currentRenderingInstance = null;\r\n    return result;\r\n}\r\nexport function shouldUpdateComponent(prevVNode, nextVNode, optimized) {\r\n    const { props: prevProps, children: prevChildren } = prevVNode;\r\n    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\r\n    if (patchFlag > 0) {\r\n        if (patchFlag & 256 /* DYNAMIC_SLOTS */) {\r\n            // slot content that references values that might have changed,\r\n            // e.g. in a v-for\r\n            return true;\r\n        }\r\n        if (patchFlag & 16 /* FULL_PROPS */) {\r\n            // presence of this flag indicates props are always non-null\r\n            return hasPropsChanged(prevProps, nextProps);\r\n        }\r\n        else if (patchFlag & 8 /* PROPS */) {\r\n            const dynamicProps = nextVNode.dynamicProps;\r\n            for (let i = 0; i < dynamicProps.length; i++) {\r\n                const key = dynamicProps[i];\r\n                if (nextProps[key] !== prevProps[key]) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (!optimized) {\r\n        // this path is only taken by manually written render functions\r\n        // so presence of any children leads to a forced update\r\n        if (prevChildren != null || nextChildren != null) {\r\n            return true;\r\n        }\r\n        if (prevProps === nextProps) {\r\n            return false;\r\n        }\r\n        if (prevProps === null) {\r\n            return nextProps !== null;\r\n        }\r\n        if (nextProps === null) {\r\n            return prevProps !== null;\r\n        }\r\n        return hasPropsChanged(prevProps, nextProps);\r\n    }\r\n    return false;\r\n}\r\nfunction hasPropsChanged(prevProps, nextProps) {\r\n    const nextKeys = Object.keys(nextProps);\r\n    if (nextKeys.length !== Object.keys(prevProps).length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < nextKeys.length; i++) {\r\n        const key = nextKeys[i];\r\n        if (nextProps[key] !== prevProps[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/component.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/vnode.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/shapeFlags.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/errorHandling.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts"]}
