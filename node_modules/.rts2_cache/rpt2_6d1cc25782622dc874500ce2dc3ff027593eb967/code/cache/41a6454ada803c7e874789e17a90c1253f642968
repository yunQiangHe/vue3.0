{"code":"import { advancePositionWithMutation, assert, isSimpleIdentifier, loadDep, toValidAssetId } from './utils';\r\nimport { isString, isArray, isSymbol } from '@vue/shared';\r\nimport { TO_STRING, CREATE_VNODE, COMMENT, helperNameMap, RESOLVE_COMPONENT, RESOLVE_DIRECTIVE } from './runtimeHelpers';\r\nfunction createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html` }) {\r\n    const context = {\r\n        mode,\r\n        prefixIdentifiers,\r\n        sourceMap,\r\n        filename,\r\n        source: ast.loc.source,\r\n        code: ``,\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        indentLevel: 0,\r\n        // lazy require source-map implementation, only in non-browser builds!\r\n        map: __BROWSER__ || !sourceMap\r\n            ? undefined\r\n            : new (loadDep('source-map')).SourceMapGenerator(),\r\n        helper(key) {\r\n            const name = helperNameMap[key];\r\n            return prefixIdentifiers ? name : `_${name}`;\r\n        },\r\n        push(code, node, openOnly) {\r\n            context.code += code;\r\n            if (!__BROWSER__ && context.map) {\r\n                if (node) {\r\n                    let name;\r\n                    if (node.type === 4 /* SIMPLE_EXPRESSION */ && !node.isStatic) {\r\n                        const content = node.content.replace(/^_ctx\\./, '');\r\n                        if (content !== node.content && isSimpleIdentifier(content)) {\r\n                            name = content;\r\n                        }\r\n                    }\r\n                    addMapping(node.loc.start, name);\r\n                }\r\n                advancePositionWithMutation(context, code);\r\n                if (node && !openOnly) {\r\n                    addMapping(node.loc.end);\r\n                }\r\n            }\r\n        },\r\n        resetMapping(loc) {\r\n            if (!__BROWSER__ && context.map) {\r\n                addMapping(loc.start);\r\n            }\r\n        },\r\n        indent() {\r\n            newline(++context.indentLevel);\r\n        },\r\n        deindent(withoutNewLine = false) {\r\n            if (withoutNewLine) {\r\n                --context.indentLevel;\r\n            }\r\n            else {\r\n                newline(--context.indentLevel);\r\n            }\r\n        },\r\n        newline() {\r\n            newline(context.indentLevel);\r\n        }\r\n    };\r\n    function newline(n) {\r\n        context.push('\\n' + `  `.repeat(n));\r\n    }\r\n    function addMapping(loc, name) {\r\n        context.map.addMapping({\r\n            name,\r\n            source: context.filename,\r\n            original: {\r\n                line: loc.line,\r\n                column: loc.column - 1 // source-map column is 0 based\r\n            },\r\n            generated: {\r\n                line: context.line,\r\n                column: context.column - 1\r\n            }\r\n        });\r\n    }\r\n    if (!__BROWSER__ && context.map) {\r\n        context.map.setSourceContent(filename, context.source);\r\n    }\r\n    return context;\r\n}\r\nexport function generate(ast, options = {}) {\r\n    const context = createCodegenContext(ast, options);\r\n    const { mode, push, helper, prefixIdentifiers, indent, deindent, newline } = context;\r\n    const hasHelpers = ast.helpers.length > 0;\r\n    const useWithBlock = !prefixIdentifiers && mode !== 'module';\r\n    // preambles\r\n    if (mode === 'function') {\r\n        // Generate const declaration for helpers\r\n        // In prefix mode, we place the const declaration at top so it's done\r\n        // only once; But if we not prefixing, we place the declaration inside the\r\n        // with block so it doesn't incur the `in` check cost for every helper access.\r\n        if (hasHelpers) {\r\n            if (prefixIdentifiers) {\r\n                push(`const { ${ast.helpers.map(helper).join(', ')} } = Vue\\n`);\r\n            }\r\n            else {\r\n                // \"with\" mode.\r\n                // save Vue in a separate variable to avoid collision\r\n                push(`const _Vue = Vue\\n`);\r\n                // in \"with\" mode, helpers are declared inside the with block to avoid\r\n                // has check cost, but hoists are lifted out of the function - we need\r\n                // to provide the helper here.\r\n                if (ast.hoists.length) {\r\n                    push(`const _${helperNameMap[CREATE_VNODE]} = Vue.createVNode\\n`);\r\n                }\r\n            }\r\n        }\r\n        genHoists(ast.hoists, context);\r\n        context.newline();\r\n        push(`return `);\r\n    }\r\n    else {\r\n        // generate import statements for helpers\r\n        if (hasHelpers) {\r\n            push(`import { ${ast.helpers.map(helper).join(', ')} } from \"vue\"\\n`);\r\n        }\r\n        genHoists(ast.hoists, context);\r\n        context.newline();\r\n        push(`export default `);\r\n    }\r\n    // enter render function\r\n    push(`function render() {`);\r\n    indent();\r\n    if (useWithBlock) {\r\n        push(`with (this) {`);\r\n        indent();\r\n        // function mode const declarations should be inside with block\r\n        // also they should be renamed to avoid collision with user properties\r\n        if (hasHelpers) {\r\n            push(`const { ${ast.helpers\r\n                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\r\n                .join(', ')} } = _Vue`);\r\n            newline();\r\n            newline();\r\n        }\r\n    }\r\n    else {\r\n        push(`const _ctx = this`);\r\n        newline();\r\n    }\r\n    // generate asset resolution statements\r\n    if (ast.components.length) {\r\n        genAssets(ast.components, 'component', context);\r\n    }\r\n    if (ast.directives.length) {\r\n        genAssets(ast.directives, 'directive', context);\r\n    }\r\n    if (ast.components.length || ast.directives.length) {\r\n        newline();\r\n    }\r\n    // generate the VNode tree expression\r\n    push(`return `);\r\n    if (ast.codegenNode) {\r\n        genNode(ast.codegenNode, context);\r\n    }\r\n    else {\r\n        push(`null`);\r\n    }\r\n    if (useWithBlock) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n    deindent();\r\n    push(`}`);\r\n    return {\r\n        ast,\r\n        code: context.code,\r\n        map: context.map ? context.map.toJSON() : undefined\r\n    };\r\n}\r\nfunction genAssets(assets, type, context) {\r\n    const resolver = context.helper(type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);\r\n    for (let i = 0; i < assets.length; i++) {\r\n        const id = assets[i];\r\n        context.push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`);\r\n        context.newline();\r\n    }\r\n}\r\nfunction genHoists(hoists, context) {\r\n    if (!hoists.length) {\r\n        return;\r\n    }\r\n    context.newline();\r\n    hoists.forEach((exp, i) => {\r\n        context.push(`const _hoisted_${i + 1} = `);\r\n        genNode(exp, context);\r\n        context.newline();\r\n    });\r\n}\r\nfunction isText(n) {\r\n    return (isString(n) ||\r\n        n.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n        n.type === 2 /* TEXT */ ||\r\n        n.type === 5 /* INTERPOLATION */ ||\r\n        n.type === 8 /* COMPOUND_EXPRESSION */);\r\n}\r\nfunction genNodeListAsArray(nodes, context) {\r\n    const multilines = nodes.length > 3 ||\r\n        ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)));\r\n    context.push(`[`);\r\n    multilines && context.indent();\r\n    genNodeList(nodes, context, multilines);\r\n    multilines && context.deindent();\r\n    context.push(`]`);\r\n}\r\nfunction genNodeList(nodes, context, multilines = false) {\r\n    const { push, newline } = context;\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        if (isString(node)) {\r\n            push(node);\r\n        }\r\n        else if (isArray(node)) {\r\n            genNodeListAsArray(node, context);\r\n        }\r\n        else {\r\n            genNode(node, context);\r\n        }\r\n        if (i < nodes.length - 1) {\r\n            if (multilines) {\r\n                push(',');\r\n                newline();\r\n            }\r\n            else {\r\n                push(', ');\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction genNode(node, context) {\r\n    if (isString(node)) {\r\n        context.push(node);\r\n        return;\r\n    }\r\n    if (isSymbol(node)) {\r\n        context.push(context.helper(node));\r\n        return;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n        case 9 /* IF */:\r\n        case 11 /* FOR */:\r\n            __DEV__ &&\r\n                assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +\r\n                    `Apply appropriate transforms first.`);\r\n            genNode(node.codegenNode, context);\r\n            break;\r\n        case 2 /* TEXT */:\r\n            genText(node, context);\r\n            break;\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            genExpression(node, context);\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            genInterpolation(node, context);\r\n            break;\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            genCompoundExpression(node, context);\r\n            break;\r\n        case 3 /* COMMENT */:\r\n            genComment(node, context);\r\n            break;\r\n        case 12 /* JS_CALL_EXPRESSION */:\r\n            genCallExpression(node, context);\r\n            break;\r\n        case 13 /* JS_OBJECT_EXPRESSION */:\r\n            genObjectExpression(node, context);\r\n            break;\r\n        case 15 /* JS_ARRAY_EXPRESSION */:\r\n            genArrayExpression(node, context);\r\n            break;\r\n        case 16 /* JS_FUNCTION_EXPRESSION */:\r\n            genFunctionExpression(node, context);\r\n            break;\r\n        case 17 /* JS_SEQUENCE_EXPRESSION */:\r\n            genSequenceExpression(node, context);\r\n            break;\r\n        case 18 /* JS_CONDITIONAL_EXPRESSION */:\r\n            genConditionalExpression(node, context);\r\n            break;\r\n        /* istanbul ignore next */\r\n        default:\r\n            if (__DEV__) {\r\n                assert(false, `unhandled codegen node type: ${node.type}`);\r\n                // make sure we exhaust all possible types\r\n                const exhaustiveCheck = node;\r\n                return exhaustiveCheck;\r\n            }\r\n    }\r\n}\r\nfunction genText(node, context) {\r\n    context.push(JSON.stringify(node.content), node);\r\n}\r\nfunction genExpression(node, context) {\r\n    const { content, isStatic } = node;\r\n    context.push(isStatic ? JSON.stringify(content) : content, node);\r\n}\r\nfunction genInterpolation(node, context) {\r\n    const { push, helper } = context;\r\n    push(`${helper(TO_STRING)}(`);\r\n    genNode(node.content, context);\r\n    push(`)`);\r\n}\r\nfunction genCompoundExpression(node, context) {\r\n    for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n        if (isString(child)) {\r\n            context.push(child);\r\n        }\r\n        else {\r\n            genNode(child, context);\r\n        }\r\n    }\r\n}\r\nfunction genExpressionAsPropertyKey(node, context) {\r\n    const { push } = context;\r\n    if (node.type === 8 /* COMPOUND_EXPRESSION */) {\r\n        push(`[`);\r\n        genCompoundExpression(node, context);\r\n        push(`]`);\r\n    }\r\n    else if (node.isStatic) {\r\n        // only quote keys if necessary\r\n        const text = isSimpleIdentifier(node.content)\r\n            ? node.content\r\n            : JSON.stringify(node.content);\r\n        push(text, node);\r\n    }\r\n    else {\r\n        push(`[${node.content}]`, node);\r\n    }\r\n}\r\nfunction genComment(node, context) {\r\n    if (__DEV__) {\r\n        const { push, helper } = context;\r\n        push(`${helper(CREATE_VNODE)}(${helper(COMMENT)}, 0, ${JSON.stringify(node.content)})`, node);\r\n    }\r\n}\r\n// JavaScript\r\nfunction genCallExpression(node, context) {\r\n    const callee = isString(node.callee)\r\n        ? node.callee\r\n        : context.helper(node.callee);\r\n    context.push(callee + `(`, node, true);\r\n    genNodeList(node.arguments, context);\r\n    context.push(`)`);\r\n}\r\nfunction genObjectExpression(node, context) {\r\n    const { push, indent, deindent, newline, resetMapping } = context;\r\n    const { properties } = node;\r\n    if (!properties.length) {\r\n        push(`{}`, node);\r\n        return;\r\n    }\r\n    const multilines = properties.length > 1 ||\r\n        ((!__BROWSER__ || __DEV__) &&\r\n            properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));\r\n    push(multilines ? `{` : `{ `);\r\n    multilines && indent();\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const { key, value, loc } = properties[i];\r\n        resetMapping(loc); // reset source mapping for every property.\r\n        // key\r\n        genExpressionAsPropertyKey(key, context);\r\n        push(`: `);\r\n        // value\r\n        genNode(value, context);\r\n        if (i < properties.length - 1) {\r\n            // will only reach this if it's multilines\r\n            push(`,`);\r\n            newline();\r\n        }\r\n    }\r\n    multilines && deindent();\r\n    const lastChar = context.code[context.code.length - 1];\r\n    push(multilines || /[\\])}]/.test(lastChar) ? `}` : ` }`);\r\n}\r\nfunction genArrayExpression(node, context) {\r\n    genNodeListAsArray(node.elements, context);\r\n}\r\nfunction genFunctionExpression(node, context) {\r\n    const { push, indent, deindent } = context;\r\n    const { params, returns, newline } = node;\r\n    push(`(`, node);\r\n    if (isArray(params)) {\r\n        genNodeList(params, context);\r\n    }\r\n    else if (params) {\r\n        genNode(params, context);\r\n    }\r\n    push(`) => `);\r\n    if (newline) {\r\n        push(`{`);\r\n        indent();\r\n        push(`return `);\r\n    }\r\n    if (isArray(returns)) {\r\n        genNodeListAsArray(returns, context);\r\n    }\r\n    else {\r\n        genNode(returns, context);\r\n    }\r\n    if (newline) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n}\r\nfunction genConditionalExpression(node, context) {\r\n    const { test, consequent, alternate } = node;\r\n    const { push, indent, deindent, newline } = context;\r\n    if (test.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        const needsParens = !isSimpleIdentifier(test.content);\r\n        needsParens && push(`(`);\r\n        genExpression(test, context);\r\n        needsParens && push(`)`);\r\n    }\r\n    else {\r\n        push(`(`);\r\n        genCompoundExpression(test, context);\r\n        push(`)`);\r\n    }\r\n    indent();\r\n    context.indentLevel++;\r\n    push(`? `);\r\n    genNode(consequent, context);\r\n    context.indentLevel--;\r\n    newline();\r\n    push(`: `);\r\n    const isNested = alternate.type === 18 /* JS_CONDITIONAL_EXPRESSION */;\r\n    if (!isNested) {\r\n        context.indentLevel++;\r\n    }\r\n    genNode(alternate, context);\r\n    if (!isNested) {\r\n        context.indentLevel--;\r\n    }\r\n    deindent(true /* without newline */);\r\n}\r\nfunction genSequenceExpression(node, context) {\r\n    context.push(`(`);\r\n    genNodeList(node.expressions, context);\r\n    context.push(`)`);\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/ast.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/node_modules/source-map/source-map.d.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/utils.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/runtimeHelpers.ts"]}
