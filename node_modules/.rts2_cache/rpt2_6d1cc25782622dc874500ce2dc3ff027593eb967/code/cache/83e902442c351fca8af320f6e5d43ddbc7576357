{"code":"import { createSequenceExpression, createCallExpression, createObjectExpression } from './ast';\r\nimport { OPEN_BLOCK, CREATE_BLOCK, MERGE_PROPS } from './runtimeHelpers';\r\nimport { isString, isFunction } from '@vue/shared';\r\n// cache node requires\r\n// lazy require dependencies so that they don't end up in rollup's dep graph\r\n// and thus can be tree-shaken in browser builds.\r\nlet _parse;\r\nlet _walk;\r\nexport function loadDep(name) {\r\n    if (typeof process !== 'undefined' && isFunction(require)) {\r\n        return require(name);\r\n    }\r\n    else {\r\n        // This is only used when we are building a dev-only build of the compiler\r\n        // which runs in the browser but also uses Node deps.\r\n        return window._deps[name];\r\n    }\r\n}\r\nexport const parseJS = (code, options) => {\r\n    assert(!__BROWSER__, `Expression AST analysis can only be performed in non-browser builds.`);\r\n    const parse = _parse || (_parse = loadDep('acorn').parse);\r\n    return parse(code, options);\r\n};\r\nexport const walkJS = (ast, walker) => {\r\n    assert(!__BROWSER__, `Expression AST analysis can only be performed in non-browser builds.`);\r\n    const walk = _walk || (_walk = loadDep('estree-walker').walk);\r\n    return walk(ast, walker);\r\n};\r\nexport const isSimpleIdentifier = (name) => !/^\\d|[^\\w]/.test(name);\r\nexport function getInnerRange(loc, offset, length) {\r\n    __DEV__ && assert(offset <= loc.source.length);\r\n    const source = loc.source.substr(offset, length);\r\n    const newLoc = {\r\n        source,\r\n        start: advancePositionWithClone(loc.start, loc.source, offset),\r\n        end: loc.end\r\n    };\r\n    if (length != null) {\r\n        __DEV__ && assert(offset + length <= loc.source.length);\r\n        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);\r\n    }\r\n    return newLoc;\r\n}\r\nexport function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\r\n    return advancePositionWithMutation({ ...pos }, source, numberOfCharacters);\r\n}\r\n// advance by mutation without cloning (for performance reasons), since this\r\n// gets called a lot in the parser\r\nexport function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\r\n    let linesCount = 0;\r\n    let lastNewLinePos = -1;\r\n    for (let i = 0; i < numberOfCharacters; i++) {\r\n        if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n            linesCount++;\r\n            lastNewLinePos = i;\r\n        }\r\n    }\r\n    pos.offset += numberOfCharacters;\r\n    pos.line += linesCount;\r\n    pos.column =\r\n        lastNewLinePos === -1\r\n            ? pos.column + numberOfCharacters\r\n            : Math.max(1, numberOfCharacters - lastNewLinePos);\r\n    return pos;\r\n}\r\nexport function assert(condition, msg) {\r\n    /* istanbul ignore if */\r\n    if (!condition) {\r\n        throw new Error(msg || `unexpected compiler condition`);\r\n    }\r\n}\r\nexport function findDir(node, name, allowEmpty = false) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 7 /* DIRECTIVE */ &&\r\n            (allowEmpty || p.exp) &&\r\n            (isString(name) ? p.name === name : name.test(p.name))) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nexport function findProp(node, name) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            if (p.name === name && p.value && !p.value.isEmpty) {\r\n                return p;\r\n            }\r\n        }\r\n        else if (p.arg &&\r\n            p.arg.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n            p.arg.isStatic &&\r\n            p.arg.content === name &&\r\n            p.exp) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nexport function createBlockExpression(args, context) {\r\n    return createSequenceExpression([\r\n        createCallExpression(context.helper(OPEN_BLOCK)),\r\n        createCallExpression(context.helper(CREATE_BLOCK), args)\r\n    ]);\r\n}\r\nexport const isVSlot = (p) => p.type === 7 /* DIRECTIVE */ && p.name === 'slot';\r\nexport const isTemplateNode = (node) => node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */;\r\nexport const isSlotOutlet = (node) => node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;\r\nexport function injectProp(props, prop, context) {\r\n    if (props == null || props === `null`) {\r\n        return createObjectExpression([prop]);\r\n    }\r\n    else if (props.type === 12 /* JS_CALL_EXPRESSION */) {\r\n        // merged props... add ours\r\n        // only inject key to object literal if it's the first argument so that\r\n        // if doesn't override user provided keys\r\n        const first = props.arguments[0];\r\n        if (!isString(first) && first.type === 13 /* JS_OBJECT_EXPRESSION */) {\r\n            first.properties.unshift(prop);\r\n        }\r\n        else {\r\n            props.arguments.unshift(createObjectExpression([prop]));\r\n        }\r\n        return props;\r\n    }\r\n    else if (props.type === 13 /* JS_OBJECT_EXPRESSION */) {\r\n        props.properties.unshift(prop);\r\n        return props;\r\n    }\r\n    else {\r\n        // single v-bind with expression, return a merged replacement\r\n        return createCallExpression(context.helper(MERGE_PROPS), [\r\n            createObjectExpression([prop]),\r\n            props\r\n        ]);\r\n    }\r\n}\r\nexport function toValidAssetId(name, type) {\r\n    return `_${type}_${name.replace(/[^\\w]/g, '')}`;\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/ast.ts","/Users/apple/Desktop/vue3/vue-next/node_modules/acorn/dist/acorn.d.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/node_modules/estree-walker/types/index.d.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transform.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/runtimeHelpers.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transforms/transformElement.ts"]}
