{"code":"import { createSimpleExpression } from './ast';\r\nimport { isString, isArray } from '@vue/shared';\r\nimport { defaultOnError } from './errors';\r\nimport { TO_STRING, COMMENT, CREATE_VNODE, FRAGMENT, helperNameMap } from './runtimeHelpers';\r\nimport { isVSlot, createBlockExpression } from './utils';\r\nimport { hoistStatic, isSingleElementRoot } from './transforms/hoistStatic';\r\nfunction createTransformContext(root, { prefixIdentifiers = false, hoistStatic = false, nodeTransforms = [], directiveTransforms = {}, onError = defaultOnError }) {\r\n    const context = {\r\n        root,\r\n        helpers: new Set(),\r\n        components: new Set(),\r\n        directives: new Set(),\r\n        hoists: [],\r\n        identifiers: {},\r\n        scopes: {\r\n            vFor: 0,\r\n            vSlot: 0,\r\n            vPre: 0,\r\n            vOnce: 0\r\n        },\r\n        prefixIdentifiers,\r\n        hoistStatic,\r\n        nodeTransforms,\r\n        directiveTransforms,\r\n        onError,\r\n        parent: null,\r\n        currentNode: root,\r\n        childIndex: 0,\r\n        helper(name) {\r\n            context.helpers.add(name);\r\n            return name;\r\n        },\r\n        helperString(name) {\r\n            return ((context.prefixIdentifiers ? `` : `_`) +\r\n                helperNameMap[context.helper(name)]);\r\n        },\r\n        replaceNode(node) {\r\n            /* istanbul ignore if */\r\n            if (__DEV__) {\r\n                if (!context.currentNode) {\r\n                    throw new Error(`Node being replaced is already removed.`);\r\n                }\r\n                if (!context.parent) {\r\n                    throw new Error(`Cannot replace root node.`);\r\n                }\r\n            }\r\n            context.parent.children[context.childIndex] = context.currentNode = node;\r\n        },\r\n        removeNode(node) {\r\n            if (__DEV__ && !context.parent) {\r\n                throw new Error(`Cannot remove root node.`);\r\n            }\r\n            const list = context.parent.children;\r\n            const removalIndex = node\r\n                ? list.indexOf(node)\r\n                : context.currentNode\r\n                    ? context.childIndex\r\n                    : -1;\r\n            /* istanbul ignore if */\r\n            if (__DEV__ && removalIndex < 0) {\r\n                throw new Error(`node being removed is not a child of current parent`);\r\n            }\r\n            if (!node || node === context.currentNode) {\r\n                // current node removed\r\n                context.currentNode = null;\r\n                context.onNodeRemoved();\r\n            }\r\n            else {\r\n                // sibling node removed\r\n                if (context.childIndex > removalIndex) {\r\n                    context.childIndex--;\r\n                    context.onNodeRemoved();\r\n                }\r\n            }\r\n            context.parent.children.splice(removalIndex, 1);\r\n        },\r\n        onNodeRemoved: () => { },\r\n        addIdentifiers(exp) {\r\n            // identifier tracking only happens in non-browser builds.\r\n            if (!__BROWSER__) {\r\n                if (isString(exp)) {\r\n                    addId(exp);\r\n                }\r\n                else if (exp.identifiers) {\r\n                    exp.identifiers.forEach(addId);\r\n                }\r\n                else if (exp.type === 4 /* SIMPLE_EXPRESSION */) {\r\n                    addId(exp.content);\r\n                }\r\n            }\r\n        },\r\n        removeIdentifiers(exp) {\r\n            if (!__BROWSER__) {\r\n                if (isString(exp)) {\r\n                    removeId(exp);\r\n                }\r\n                else if (exp.identifiers) {\r\n                    exp.identifiers.forEach(removeId);\r\n                }\r\n                else if (exp.type === 4 /* SIMPLE_EXPRESSION */) {\r\n                    removeId(exp.content);\r\n                }\r\n            }\r\n        },\r\n        hoist(exp) {\r\n            context.hoists.push(exp);\r\n            return createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc);\r\n        }\r\n    };\r\n    function addId(id) {\r\n        const { identifiers } = context;\r\n        if (identifiers[id] === undefined) {\r\n            identifiers[id] = 0;\r\n        }\r\n        identifiers[id]++;\r\n    }\r\n    function removeId(id) {\r\n        context.identifiers[id]--;\r\n    }\r\n    return context;\r\n}\r\nexport function transform(root, options) {\r\n    const context = createTransformContext(root, options);\r\n    traverseNode(root, context);\r\n    if (options.hoistStatic) {\r\n        hoistStatic(root, context);\r\n    }\r\n    finalizeRoot(root, context);\r\n}\r\nfunction finalizeRoot(root, context) {\r\n    const { helper } = context;\r\n    const { children } = root;\r\n    const child = children[0];\r\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\r\n        // turn root element into a block\r\n        root.codegenNode = createBlockExpression(child.codegenNode.arguments, context);\r\n    }\r\n    else if (children.length === 1) {\r\n        // - single <slot/>, IfNode, ForNode: already blocks.\r\n        // - single text node: always patched.\r\n        // - transform calls without transformElement (only during tests)\r\n        // Just generate the node as-is\r\n        root.codegenNode = child;\r\n    }\r\n    else if (children.length > 1) {\r\n        // root has multiple nodes - return a fragment block.\r\n        root.codegenNode = createBlockExpression([helper(FRAGMENT), `null`, root.children], context);\r\n    }\r\n    // finalize meta information\r\n    root.helpers = [...context.helpers];\r\n    root.components = [...context.components];\r\n    root.directives = [...context.directives];\r\n    root.hoists = context.hoists;\r\n}\r\nexport function traverseChildren(parent, context) {\r\n    let i = 0;\r\n    const nodeRemoved = () => {\r\n        i--;\r\n    };\r\n    for (; i < parent.children.length; i++) {\r\n        const child = parent.children[i];\r\n        if (isString(child))\r\n            continue;\r\n        context.currentNode = child;\r\n        context.parent = parent;\r\n        context.childIndex = i;\r\n        context.onNodeRemoved = nodeRemoved;\r\n        traverseNode(child, context);\r\n    }\r\n}\r\nexport function traverseNode(node, context) {\r\n    // apply transform plugins\r\n    const { nodeTransforms } = context;\r\n    const exitFns = [];\r\n    for (let i = 0; i < nodeTransforms.length; i++) {\r\n        const onExit = nodeTransforms[i](node, context);\r\n        if (onExit) {\r\n            if (isArray(onExit)) {\r\n                exitFns.push(...onExit);\r\n            }\r\n            else {\r\n                exitFns.push(onExit);\r\n            }\r\n        }\r\n        if (!context.currentNode) {\r\n            // node was removed\r\n            return;\r\n        }\r\n        else {\r\n            // node may have been replaced\r\n            node = context.currentNode;\r\n        }\r\n    }\r\n    switch (node.type) {\r\n        case 3 /* COMMENT */:\r\n            // inject import for the Comment symbol, which is needed for creating\r\n            // comment nodes with `createVNode`\r\n            context.helper(CREATE_VNODE);\r\n            context.helper(COMMENT);\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            // no need to traverse, but we need to inject toString helper\r\n            context.helper(TO_STRING);\r\n            break;\r\n        // for container types, further traverse downwards\r\n        case 9 /* IF */:\r\n            for (let i = 0; i < node.branches.length; i++) {\r\n                traverseChildren(node.branches[i], context);\r\n            }\r\n            break;\r\n        case 11 /* FOR */:\r\n        case 1 /* ELEMENT */:\r\n        case 0 /* ROOT */:\r\n            traverseChildren(node, context);\r\n            break;\r\n    }\r\n    // exit transforms\r\n    for (let i = 0; i < exitFns.length; i++) {\r\n        exitFns[i]();\r\n    }\r\n}\r\nexport function createStructuralDirectiveTransform(name, fn) {\r\n    const matches = isString(name)\r\n        ? (n) => n === name\r\n        : (n) => name.test(n);\r\n    return (node, context) => {\r\n        if (node.type === 1 /* ELEMENT */) {\r\n            const { props } = node;\r\n            // structural directive transforms are not concerned with slots\r\n            // as they are handled separately in vSlot.ts\r\n            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {\r\n                return;\r\n            }\r\n            const exitFns = [];\r\n            for (let i = 0; i < props.length; i++) {\r\n                const prop = props[i];\r\n                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {\r\n                    // structural directives are removed to avoid infinite recursion\r\n                    // also we remove them *before* applying so that it can further\r\n                    // traverse itself in case it moves the node around\r\n                    props.splice(i, 1);\r\n                    i--;\r\n                    const onExit = fn(node, prop, context);\r\n                    if (onExit)\r\n                        exitFns.push(onExit);\r\n                }\r\n            }\r\n            return exitFns;\r\n        }\r\n    };\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/ast.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/errors.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/runtimeHelpers.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/utils.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transforms/hoistStatic.ts"]}
