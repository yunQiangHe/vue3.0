{"code":"import { targetMap } from './reactive';\r\nimport { EMPTY_OBJ, extend } from '@vue/shared';\r\nexport const activeReactiveEffectStack = [];\r\nexport const ITERATE_KEY = Symbol('iterate');\r\nexport function effect(fn, options = EMPTY_OBJ) {\r\n    if (fn.isEffect) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nexport function stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.onStop) {\r\n            effect.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function effect(...args) {\r\n        return run(effect, fn, args);\r\n    };\r\n    effect.isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.scheduler = options.scheduler;\r\n    effect.onTrack = options.onTrack;\r\n    effect.onTrigger = options.onTrigger;\r\n    effect.onStop = options.onStop;\r\n    effect.computed = options.computed;\r\n    effect.deps = [];\r\n    return effect;\r\n}\r\nfunction run(effect, fn, args) {\r\n    if (!effect.active) {\r\n        return fn(...args);\r\n    }\r\n    if (activeReactiveEffectStack.indexOf(effect) === -1) {\r\n        cleanup(effect);\r\n        try {\r\n            activeReactiveEffectStack.push(effect);\r\n            return fn(...args);\r\n        }\r\n        finally {\r\n            activeReactiveEffectStack.pop();\r\n        }\r\n    }\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nexport function pauseTracking() {\r\n    shouldTrack = false;\r\n}\r\nexport function resumeTracking() {\r\n    shouldTrack = true;\r\n}\r\nexport function track(target, type, key) {\r\n    if (!shouldTrack) {\r\n        return;\r\n    }\r\n    const effect = activeReactiveEffectStack[activeReactiveEffectStack.length - 1];\r\n    if (effect) {\r\n        if (type === \"iterate\" /* ITERATE */) {\r\n            key = ITERATE_KEY;\r\n        }\r\n        let depsMap = targetMap.get(target);\r\n        if (depsMap === void 0) {\r\n            targetMap.set(target, (depsMap = new Map()));\r\n        }\r\n        let dep = depsMap.get(key);\r\n        if (dep === void 0) {\r\n            depsMap.set(key, (dep = new Set()));\r\n        }\r\n        if (!dep.has(effect)) {\r\n            dep.add(effect);\r\n            effect.deps.push(dep);\r\n            if (__DEV__ && effect.onTrack) {\r\n                effect.onTrack({\r\n                    effect,\r\n                    target,\r\n                    type,\r\n                    key\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\nexport function trigger(target, type, key, extraInfo) {\r\n    const depsMap = targetMap.get(target);\r\n    if (depsMap === void 0) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const computedRunners = new Set();\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared, trigger all effects for target\r\n        depsMap.forEach(dep => {\r\n            addRunners(effects, computedRunners, dep);\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            addRunners(effects, computedRunners, depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE\r\n        if (type === \"add\" /* ADD */ || type === \"delete\" /* DELETE */) {\r\n            const iterationKey = Array.isArray(target) ? 'length' : ITERATE_KEY;\r\n            addRunners(effects, computedRunners, depsMap.get(iterationKey));\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        scheduleRun(effect, target, type, key, extraInfo);\r\n    };\r\n    // Important: computed effects must be run first so that computed getters\r\n    // can be invalidated before any normal effects that depend on them are run.\r\n    computedRunners.forEach(run);\r\n    effects.forEach(run);\r\n}\r\nfunction addRunners(effects, computedRunners, effectsToAdd) {\r\n    if (effectsToAdd !== void 0) {\r\n        effectsToAdd.forEach(effect => {\r\n            if (effect.computed) {\r\n                computedRunners.add(effect);\r\n            }\r\n            else {\r\n                effects.add(effect);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction scheduleRun(effect, target, type, key, extraInfo) {\r\n    if (__DEV__ && effect.onTrigger) {\r\n        effect.onTrigger(extend({\r\n            effect,\r\n            target,\r\n            key,\r\n            type\r\n        }, extraInfo));\r\n    }\r\n    if (effect.scheduler !== void 0) {\r\n        effect.scheduler(effect);\r\n    }\r\n    else {\r\n        effect();\r\n    }\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/operations.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/reactive.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts"]}
