{"code":"import { toRaw, reactive, readonly } from './reactive';\r\nimport { track, trigger } from './effect';\r\nimport { LOCKED } from './lock';\r\nimport { isObject, capitalize, hasOwn } from '@vue/shared';\r\nconst toReactive = (value) => (isObject(value) ? reactive(value) : value);\r\nconst toReadonly = (value) => (isObject(value) ? readonly(value) : value);\r\nfunction get(target, key, wrap) {\r\n    target = toRaw(target);\r\n    key = toRaw(key);\r\n    const proto = Reflect.getPrototypeOf(target);\r\n    track(target, \"get\" /* GET */, key);\r\n    const res = proto.get.call(target, key);\r\n    return wrap(res);\r\n}\r\nfunction has(key) {\r\n    const target = toRaw(this);\r\n    key = toRaw(key);\r\n    const proto = Reflect.getPrototypeOf(target);\r\n    track(target, \"has\" /* HAS */, key);\r\n    return proto.has.call(target, key);\r\n}\r\nfunction size(target) {\r\n    target = toRaw(target);\r\n    const proto = Reflect.getPrototypeOf(target);\r\n    track(target, \"iterate\" /* ITERATE */);\r\n    return Reflect.get(proto, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = Reflect.getPrototypeOf(this);\r\n    const hadKey = proto.has.call(target, value);\r\n    const result = proto.add.call(target, value);\r\n    if (!hadKey) {\r\n        /* istanbul ignore else */\r\n        if (__DEV__) {\r\n            trigger(target, \"add\" /* ADD */, value, { value });\r\n        }\r\n        else {\r\n            trigger(target, \"add\" /* ADD */, value);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction set(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = Reflect.getPrototypeOf(this);\r\n    const hadKey = proto.has.call(target, key);\r\n    const oldValue = proto.get.call(target, key);\r\n    const result = proto.set.call(target, key, value);\r\n    if (value !== oldValue) {\r\n        /* istanbul ignore else */\r\n        if (__DEV__) {\r\n            const extraInfo = { oldValue, newValue: value };\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, extraInfo);\r\n            }\r\n            else {\r\n                trigger(target, \"set\" /* SET */, key, extraInfo);\r\n            }\r\n        }\r\n        else {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key);\r\n            }\r\n            else {\r\n                trigger(target, \"set\" /* SET */, key);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const proto = Reflect.getPrototypeOf(this);\r\n    const hadKey = proto.has.call(target, key);\r\n    const oldValue = proto.get ? proto.get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = proto.delete.call(target, key);\r\n    if (hadKey) {\r\n        /* istanbul ignore else */\r\n        if (__DEV__) {\r\n            trigger(target, \"delete\" /* DELETE */, key, { oldValue });\r\n        }\r\n        else {\r\n            trigger(target, \"delete\" /* DELETE */, key);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const proto = Reflect.getPrototypeOf(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = target instanceof Map ? new Map(target) : new Set(target);\r\n    // forward the operation before queueing reactions\r\n    const result = proto.clear.call(target);\r\n    if (hadItems) {\r\n        /* istanbul ignore else */\r\n        if (__DEV__) {\r\n            trigger(target, \"clear\" /* CLEAR */, void 0, { oldTarget });\r\n        }\r\n        else {\r\n            trigger(target, \"clear\" /* CLEAR */);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = toRaw(observed);\r\n        const proto = Reflect.getPrototypeOf(target);\r\n        const wrap = isReadonly ? toReadonly : toReactive;\r\n        track(target, \"iterate\" /* ITERATE */);\r\n        // important: create sure the callback is\r\n        // 1. invoked with the reactive map as `this` and 3rd arg\r\n        // 2. the value received should be a corresponding reactive/readonly.\r\n        function wrappedCallback(value, key) {\r\n            return callback.call(observed, wrap(value), wrap(key), observed);\r\n        }\r\n        return proto.forEach.call(target, wrappedCallback, thisArg);\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly) {\r\n    return function (...args) {\r\n        const target = toRaw(this);\r\n        const proto = Reflect.getPrototypeOf(target);\r\n        const isPair = method === 'entries' ||\r\n            (method === Symbol.iterator && target instanceof Map);\r\n        const innerIterator = proto[method].apply(target, args);\r\n        const wrap = isReadonly ? toReadonly : toReactive;\r\n        track(target, \"iterate\" /* ITERATE */);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(method, type) {\r\n    return function (...args) {\r\n        if (LOCKED) {\r\n            if (__DEV__) {\r\n                const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n                console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n            }\r\n            return type === \"delete\" /* DELETE */ ? false : this;\r\n        }\r\n        else {\r\n            return method.apply(this, args);\r\n        }\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get(this, key, toReactive);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get(this, key, toReadonly);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has,\r\n    add: createReadonlyMethod(add, \"add\" /* ADD */),\r\n    set: createReadonlyMethod(set, \"set\" /* SET */),\r\n    delete: createReadonlyMethod(deleteEntry, \"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(clear, \"clear\" /* CLEAR */),\r\n    forEach: createForEach(true)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true);\r\n});\r\nfunction createInstrumentationGetter(instrumentations) {\r\n    return function getInstrumented(target, key, receiver) {\r\n        target =\r\n            hasOwn(instrumentations, key) && key in target ? instrumentations : target;\r\n        return Reflect.get(target, key, receiver);\r\n    };\r\n}\r\nexport const mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(mutableInstrumentations)\r\n};\r\nexport const readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(readonlyInstrumentations)\r\n};\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/reactive.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/effect.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/operations.ts","/Users/apple/Desktop/vue3/vue-next/packages/reactivity/src/lock.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts"]}
