{"code":"/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\nconst comp = resolveComponent('comp')\r\nconst foo = resolveDirective('foo')\r\nconst bar = resolveDirective('bar')\r\n\nreturn applyDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\nimport { cloneVNode } from './vnode';\r\nimport { extend, isArray, isFunction } from '@vue/shared';\r\nimport { warn } from './warning';\r\nimport { currentRenderingInstance } from './componentRenderUtils';\r\nimport { callWithAsyncErrorHandling } from './errorHandling';\r\nconst valueCache = new WeakMap();\r\nfunction applyDirective(props, instance, directive, value, arg, modifiers) {\r\n    let valueCacheForDir = valueCache.get(directive);\r\n    if (!valueCacheForDir) {\r\n        valueCacheForDir = new WeakMap();\r\n        valueCache.set(directive, valueCacheForDir);\r\n    }\r\n    for (const key in directive) {\r\n        const hook = directive[key];\r\n        const hookKey = `vnode` + key[0].toUpperCase() + key.slice(1);\r\n        const vnodeHook = (vnode, prevVNode) => {\r\n            let oldValue;\r\n            if (prevVNode != null) {\r\n                oldValue = valueCacheForDir.get(prevVNode);\r\n                valueCacheForDir.delete(prevVNode);\r\n            }\r\n            valueCacheForDir.set(vnode, value);\r\n            hook(vnode.el, {\r\n                instance: instance.renderProxy,\r\n                value,\r\n                oldValue,\r\n                arg,\r\n                modifiers\r\n            }, vnode, prevVNode);\r\n        };\r\n        const existing = props[hookKey];\r\n        props[hookKey] = existing\r\n            ? [].concat(existing, vnodeHook)\r\n            : vnodeHook;\r\n    }\r\n}\r\nexport function applyDirectives(vnode, directives) {\r\n    const instance = currentRenderingInstance;\r\n    if (instance !== null) {\r\n        vnode = cloneVNode(vnode);\r\n        vnode.props = vnode.props != null ? extend({}, vnode.props) : {};\r\n        for (let i = 0; i < directives.length; i++) {\r\n            ;\r\n            applyDirective(vnode.props, instance, ...directives[i]);\r\n        }\r\n    }\r\n    else if (__DEV__) {\r\n        warn(`applyDirectives can only be used inside render functions.`);\r\n    }\r\n    return vnode;\r\n}\r\nexport function invokeDirectiveHook(hook, instance, vnode, prevVNode = null) {\r\n    const args = [vnode, prevVNode];\r\n    if (isArray(hook)) {\r\n        for (let i = 0; i < hook.length; i++) {\r\n            callWithAsyncErrorHandling(hook[i], instance, 7 /* DIRECTIVE_HOOK */, args);\r\n        }\r\n    }\r\n    else if (isFunction(hook)) {\r\n        callWithAsyncErrorHandling(hook, instance, 7 /* DIRECTIVE_HOOK */, args);\r\n    }\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/vnode.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/warning.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/component.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentRenderUtils.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/errorHandling.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/componentProxy.ts"]}
