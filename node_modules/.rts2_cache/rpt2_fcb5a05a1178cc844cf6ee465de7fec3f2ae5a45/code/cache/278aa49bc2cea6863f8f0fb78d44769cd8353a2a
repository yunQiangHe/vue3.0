{"code":"import { isArray } from '@vue/shared';\r\nimport { callWithAsyncErrorHandling } from '@vue/runtime-core';\r\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nlet _getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res ( relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\nif (typeof document !== 'undefined' &&\r\n    _getNow() > document.createEvent('Event').timeStamp) {\r\n    // if the low-res timestamp which is bigger than the event timestamp\r\n    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n    // and we need to use the hi-res version for event listeners as well.\r\n    _getNow = () => performance.now();\r\n}\r\n// To avoid the overhead of repeatedly calling performance.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow = 0;\r\nconst p = Promise.resolve();\r\nconst reset = () => {\r\n    cachedNow = 0;\r\n};\r\nconst getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));\r\nexport function patchEvent(el, name, prevValue, nextValue, instance = null) {\r\n    const invoker = prevValue && prevValue.invoker;\r\n    if (nextValue) {\r\n        if (invoker) {\r\n            ;\r\n            prevValue.invoker = null;\r\n            invoker.value = nextValue;\r\n            nextValue.invoker = invoker;\r\n            invoker.lastUpdated = getNow();\r\n        }\r\n        else {\r\n            el.addEventListener(name, createInvoker(nextValue, instance));\r\n        }\r\n    }\r\n    else if (invoker) {\r\n        el.removeEventListener(name, invoker);\r\n    }\r\n}\r\nfunction createInvoker(initialValue, instance) {\r\n    const invoker = ((e) => {\r\n        // async edge case #6566: inner click event triggers patch, event handler\r\n        // attached to outer element during patch, and triggered again. This\r\n        // happens because browsers fire microtask ticks between event propagation.\r\n        // the solution is simple: we save the timestamp when a handler is attached,\r\n        // and the handler would only fire if the event passed to it was fired\r\n        // AFTER it was attached.\r\n        if (e.timeStamp >= invoker.lastUpdated) {\r\n            const args = [e];\r\n            const value = invoker.value;\r\n            if (isArray(value)) {\r\n                for (let i = 0; i < value.length; i++) {\r\n                    callWithAsyncErrorHandling(value[i], instance, 5 /* NATIVE_EVENT_HANDLER */, args);\r\n                }\r\n            }\r\n            else {\r\n                callWithAsyncErrorHandling(value, instance, 5 /* NATIVE_EVENT_HANDLER */, args);\r\n            }\r\n        }\r\n    });\r\n    invoker.value = initialValue;\r\n    initialValue.invoker = invoker;\r\n    invoker.lastUpdated = getNow();\r\n    return invoker;\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/runtime-core/src/errorHandling.ts"]}
