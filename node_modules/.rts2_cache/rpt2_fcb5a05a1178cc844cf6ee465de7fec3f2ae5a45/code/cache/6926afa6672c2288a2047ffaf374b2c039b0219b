{"code":"import { createStructuralDirectiveTransform, traverseChildren } from '../transform';\r\nimport { createSequenceExpression, createCallExpression, createConditionalExpression, createSimpleExpression, createObjectProperty, createObjectExpression } from '../ast';\r\nimport { createCompilerError } from '../errors';\r\nimport { processExpression } from './transformExpression';\r\nimport { OPEN_BLOCK, CREATE_BLOCK, EMPTY, FRAGMENT, APPLY_DIRECTIVES, CREATE_VNODE, RENDER_SLOT } from '../runtimeHelpers';\r\nimport { injectProp } from '../utils';\r\nexport const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {\r\n    if (dir.name !== 'else' &&\r\n        (!dir.exp || !dir.exp.content.trim())) {\r\n        const loc = dir.exp ? dir.exp.loc : node.loc;\r\n        context.onError(createCompilerError(35 /* X_IF_NO_EXPRESSION */, dir.loc));\r\n        dir.exp = createSimpleExpression(`true`, false, loc);\r\n    }\r\n    if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {\r\n        // dir.exp can only be simple expression because vIf transform is applied\r\n        // before expression transform.\r\n        dir.exp = processExpression(dir.exp, context);\r\n    }\r\n    if (dir.name === 'if') {\r\n        const branch = createIfBranch(node, dir);\r\n        const codegenNode = createSequenceExpression([\r\n            createCallExpression(context.helper(OPEN_BLOCK))\r\n        ]);\r\n        context.replaceNode({\r\n            type: 9 /* IF */,\r\n            loc: node.loc,\r\n            branches: [branch],\r\n            codegenNode\r\n        });\r\n        // Exit callback. Complete the codegenNode when all children have been\r\n        // transformed.\r\n        return () => {\r\n            codegenNode.expressions.push(createCodegenNodeForBranch(branch, 0, context));\r\n        };\r\n    }\r\n    else {\r\n        // locate the adjacent v-if\r\n        const siblings = context.parent.children;\r\n        const comments = [];\r\n        let i = siblings.indexOf(node);\r\n        while (i-- >= -1) {\r\n            const sibling = siblings[i];\r\n            if (__DEV__ && sibling && sibling.type === 3 /* COMMENT */) {\r\n                context.removeNode(sibling);\r\n                comments.unshift(sibling);\r\n                continue;\r\n            }\r\n            if (sibling && sibling.type === 9 /* IF */) {\r\n                // move the node to the if node's branches\r\n                context.removeNode();\r\n                const branch = createIfBranch(node, dir);\r\n                if (__DEV__ && comments.length) {\r\n                    branch.children = [...comments, ...branch.children];\r\n                }\r\n                sibling.branches.push(branch);\r\n                // since the branch was removed, it will not be traversed.\r\n                // make sure to traverse here.\r\n                traverseChildren(branch, context);\r\n                // make sure to reset currentNode after traversal to indicate this\r\n                // node has been removed.\r\n                context.currentNode = null;\r\n                // attach this branch's codegen node to the v-if root.\r\n                let parentCondition = sibling.codegenNode\r\n                    .expressions[1];\r\n                while (true) {\r\n                    if (parentCondition.alternate.type ===\r\n                        18 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                        parentCondition = parentCondition.alternate;\r\n                    }\r\n                    else {\r\n                        parentCondition.alternate = createCodegenNodeForBranch(branch, sibling.branches.length - 1, context);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(36 /* X_ELSE_NO_ADJACENT_IF */, node.loc));\r\n            }\r\n            break;\r\n        }\r\n    }\r\n});\r\nfunction createIfBranch(node, dir) {\r\n    return {\r\n        type: 10 /* IF_BRANCH */,\r\n        loc: node.loc,\r\n        condition: dir.name === 'else' ? undefined : dir.exp,\r\n        children: node.tagType === 3 /* TEMPLATE */ ? node.children : [node]\r\n    };\r\n}\r\nfunction createCodegenNodeForBranch(branch, index, context) {\r\n    if (branch.condition) {\r\n        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, index, context), createCallExpression(context.helper(CREATE_BLOCK), [\r\n            context.helper(EMPTY)\r\n        ]));\r\n    }\r\n    else {\r\n        return createChildrenCodegenNode(branch, index, context);\r\n    }\r\n}\r\nfunction createChildrenCodegenNode(branch, index, context) {\r\n    const { helper } = context;\r\n    const keyProperty = createObjectProperty(`key`, createSimpleExpression(index + '', false));\r\n    const { children } = branch;\r\n    const child = children[0];\r\n    const needFragmentWrapper = children.length !== 1 || child.type !== 1 /* ELEMENT */;\r\n    if (needFragmentWrapper) {\r\n        const blockArgs = [\r\n            helper(FRAGMENT),\r\n            createObjectExpression([keyProperty]),\r\n            children\r\n        ];\r\n        if (children.length === 1 && child.type === 11 /* FOR */) {\r\n            // optimize away nested fragments when child is a ForNode\r\n            const forBlockArgs = child.codegenNode.expressions[1].arguments;\r\n            // directly use the for block's children and patchFlag\r\n            blockArgs[2] = forBlockArgs[2];\r\n            blockArgs[3] = forBlockArgs[3];\r\n        }\r\n        return createCallExpression(helper(CREATE_BLOCK), blockArgs);\r\n    }\r\n    else {\r\n        const childCodegen = child.codegenNode;\r\n        let vnodeCall = childCodegen;\r\n        // Element with custom directives. Locate the actual createVNode() call.\r\n        if (vnodeCall.callee === APPLY_DIRECTIVES) {\r\n            vnodeCall = vnodeCall.arguments[0];\r\n        }\r\n        // Change createVNode to createBlock.\r\n        if (vnodeCall.callee === CREATE_VNODE) {\r\n            ;\r\n            vnodeCall.callee = helper(CREATE_BLOCK);\r\n        }\r\n        // It's possible to have renderSlot() here as well - which already produces\r\n        // a block, so no need to change the callee. However it accepts props at\r\n        // a different arg index so make sure to check for so that the key injection\r\n        // logic below works for it too.\r\n        const propsIndex = vnodeCall.callee === RENDER_SLOT ? 2 : 1;\r\n        // inject branch key\r\n        const existingProps = vnodeCall.arguments[propsIndex];\r\n        vnodeCall.arguments[propsIndex] = injectProp(existingProps, keyProperty, context);\r\n        return childCodegen;\r\n    }\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transform.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/ast.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/errors.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transforms/transformExpression.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/runtimeHelpers.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/utils.ts"]}
