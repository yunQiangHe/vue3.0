{"code":"import { createCallExpression, createArrayExpression, createObjectProperty, createSimpleExpression, createObjectExpression } from '../ast';\r\nimport { isArray, PatchFlagNames } from '@vue/shared';\r\nimport { createCompilerError } from '../errors';\r\nimport { CREATE_VNODE, APPLY_DIRECTIVES, RESOLVE_DIRECTIVE, RESOLVE_COMPONENT, MERGE_PROPS, TO_HANDLERS } from '../runtimeHelpers';\r\nimport { getInnerRange, isVSlot, toValidAssetId } from '../utils';\r\nimport { buildSlots } from './vSlot';\r\n// generate a JavaScript AST for this element's codegen\r\nexport const transformElement = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */) {\r\n        if (node.tagType === 0 /* ELEMENT */ ||\r\n            node.tagType === 1 /* COMPONENT */ ||\r\n            // <template> with v-if or v-for are ignored during traversal.\r\n            // <template> without v-slot should be treated as a normal element.\r\n            (node.tagType === 3 /* TEMPLATE */ && !node.props.some(isVSlot))) {\r\n            // perform the work on exit, after all child expressions have been\r\n            // processed and merged.\r\n            return () => {\r\n                const isComponent = node.tagType === 1 /* COMPONENT */;\r\n                let hasProps = node.props.length > 0;\r\n                const hasChildren = node.children.length > 0;\r\n                let patchFlag = 0;\r\n                let runtimeDirectives;\r\n                let dynamicPropNames;\r\n                if (isComponent) {\r\n                    context.helper(RESOLVE_COMPONENT);\r\n                    context.components.add(node.tag);\r\n                }\r\n                const args = [\r\n                    isComponent ? toValidAssetId(node.tag, `component`) : `\"${node.tag}\"`\r\n                ];\r\n                // props\r\n                if (hasProps) {\r\n                    const propsBuildResult = buildProps(node.props, node.loc, context, isComponent);\r\n                    patchFlag = propsBuildResult.patchFlag;\r\n                    dynamicPropNames = propsBuildResult.dynamicPropNames;\r\n                    runtimeDirectives = propsBuildResult.directives;\r\n                    if (!propsBuildResult.props) {\r\n                        hasProps = false;\r\n                    }\r\n                    else {\r\n                        args.push(propsBuildResult.props);\r\n                    }\r\n                }\r\n                // children\r\n                if (hasChildren) {\r\n                    if (!hasProps) {\r\n                        args.push(`null`);\r\n                    }\r\n                    if (isComponent) {\r\n                        const { slots, hasDynamicSlots } = buildSlots(node, context);\r\n                        args.push(slots);\r\n                        if (hasDynamicSlots) {\r\n                            patchFlag |= 256 /* DYNAMIC_SLOTS */;\r\n                        }\r\n                    }\r\n                    else if (node.children.length === 1) {\r\n                        const child = node.children[0];\r\n                        const type = child.type;\r\n                        const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||\r\n                            type === 8 /* COMPOUND_EXPRESSION */;\r\n                        if (hasDynamicTextChild) {\r\n                            patchFlag |= 1 /* TEXT */;\r\n                        }\r\n                        // pass directly if the only child is a text node\r\n                        // (plain / interpolation / expression)\r\n                        if (hasDynamicTextChild || type === 2 /* TEXT */) {\r\n                            args.push(child);\r\n                        }\r\n                        else {\r\n                            args.push(node.children);\r\n                        }\r\n                    }\r\n                    else {\r\n                        args.push(node.children);\r\n                    }\r\n                }\r\n                // patchFlag & dynamicPropNames\r\n                if (patchFlag !== 0) {\r\n                    if (!hasChildren) {\r\n                        if (!hasProps) {\r\n                            args.push(`null`);\r\n                        }\r\n                        args.push(`null`);\r\n                    }\r\n                    if (__DEV__) {\r\n                        const flagNames = Object.keys(PatchFlagNames)\r\n                            .map(Number)\r\n                            .filter(n => n > 0 && patchFlag & n)\r\n                            .map(n => PatchFlagNames[n])\r\n                            .join(`, `);\r\n                        args.push(patchFlag + ` /* ${flagNames} */`);\r\n                    }\r\n                    else {\r\n                        args.push(patchFlag + '');\r\n                    }\r\n                    if (dynamicPropNames && dynamicPropNames.length) {\r\n                        args.push(`[${dynamicPropNames.map(n => JSON.stringify(n)).join(`, `)}]`);\r\n                    }\r\n                }\r\n                const { loc } = node;\r\n                const vnode = createCallExpression(context.helper(CREATE_VNODE), args, loc);\r\n                if (runtimeDirectives && runtimeDirectives.length) {\r\n                    node.codegenNode = createCallExpression(context.helper(APPLY_DIRECTIVES), [\r\n                        vnode,\r\n                        createArrayExpression(runtimeDirectives.map(dir => {\r\n                            return createDirectiveArgs(dir, context);\r\n                        }), loc)\r\n                    ], loc);\r\n                }\r\n                else {\r\n                    node.codegenNode = vnode;\r\n                }\r\n            };\r\n        }\r\n    }\r\n};\r\nexport function buildProps(props, elementLoc, context, isComponent = false) {\r\n    let properties = [];\r\n    const mergeArgs = [];\r\n    const runtimeDirectives = [];\r\n    // patchFlag analysis\r\n    let patchFlag = 0;\r\n    let hasRef = false;\r\n    let hasClassBinding = false;\r\n    let hasStyleBinding = false;\r\n    let hasDynamicKeys = false;\r\n    const dynamicPropNames = [];\r\n    const analyzePatchFlag = ({ key, value }) => {\r\n        if (key.type === 4 /* SIMPLE_EXPRESSION */ && key.isStatic) {\r\n            if (value.type !== 4 /* SIMPLE_EXPRESSION */ || !value.isStatic) {\r\n                const name = key.content;\r\n                if (name === 'ref') {\r\n                    hasRef = true;\r\n                }\r\n                else if (name === 'class') {\r\n                    hasClassBinding = true;\r\n                }\r\n                else if (name === 'style') {\r\n                    hasStyleBinding = true;\r\n                }\r\n                else if (name !== 'key') {\r\n                    dynamicPropNames.push(key.content);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            hasDynamicKeys = true;\r\n        }\r\n    };\r\n    for (let i = 0; i < props.length; i++) {\r\n        // static attribute\r\n        const prop = props[i];\r\n        if (prop.type === 6 /* ATTRIBUTE */) {\r\n            const { loc, name, value } = prop;\r\n            if (name === 'ref') {\r\n                hasRef = true;\r\n            }\r\n            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', true, value ? value.loc : loc)));\r\n        }\r\n        else {\r\n            // directives\r\n            const { name, arg, exp, loc } = prop;\r\n            // skip v-slot - it is handled by its dedicated transform.\r\n            if (name === 'slot') {\r\n                if (!isComponent) {\r\n                    context.onError(createCompilerError(46 /* X_MISPLACED_V_SLOT */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            // special case for v-bind and v-on with no argument\r\n            const isBind = name === 'bind';\r\n            const isOn = name === 'on';\r\n            if (!arg && (isBind || isOn)) {\r\n                hasDynamicKeys = true;\r\n                if (exp) {\r\n                    if (properties.length) {\r\n                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n                        properties = [];\r\n                    }\r\n                    if (isBind) {\r\n                        mergeArgs.push(exp);\r\n                    }\r\n                    else {\r\n                        // v-on=\"obj\" -> toHandlers(obj)\r\n                        mergeArgs.push({\r\n                            type: 12 /* JS_CALL_EXPRESSION */,\r\n                            loc,\r\n                            callee: context.helper(TO_HANDLERS),\r\n                            arguments: [exp]\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    context.onError(createCompilerError(isBind\r\n                        ? 39 /* X_V_BIND_NO_EXPRESSION */\r\n                        : 40 /* X_V_ON_NO_EXPRESSION */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            const directiveTransform = context.directiveTransforms[name];\r\n            if (directiveTransform) {\r\n                // has built-in directive transform.\r\n                const { props, needRuntime } = directiveTransform(prop, context);\r\n                if (isArray(props)) {\r\n                    properties.push(...props);\r\n                    properties.forEach(analyzePatchFlag);\r\n                }\r\n                else {\r\n                    properties.push(props);\r\n                    analyzePatchFlag(props);\r\n                }\r\n                if (needRuntime) {\r\n                    runtimeDirectives.push(prop);\r\n                }\r\n            }\r\n            else {\r\n                // no built-in transform, this is a user custom directive.\r\n                runtimeDirectives.push(prop);\r\n            }\r\n        }\r\n    }\r\n    let propsExpression = undefined;\r\n    // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\r\n    if (mergeArgs.length) {\r\n        if (properties.length) {\r\n            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n        }\r\n        if (mergeArgs.length > 1) {\r\n            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);\r\n        }\r\n        else {\r\n            // single v-bind with nothing else - no need for a mergeProps call\r\n            propsExpression = mergeArgs[0];\r\n        }\r\n    }\r\n    else if (properties.length) {\r\n        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);\r\n    }\r\n    // patchFlag analysis\r\n    if (hasDynamicKeys) {\r\n        patchFlag |= 16 /* FULL_PROPS */;\r\n    }\r\n    else {\r\n        if (hasClassBinding) {\r\n            patchFlag |= 2 /* CLASS */;\r\n        }\r\n        if (hasStyleBinding) {\r\n            patchFlag |= 4 /* STYLE */;\r\n        }\r\n        if (dynamicPropNames.length) {\r\n            patchFlag |= 8 /* PROPS */;\r\n        }\r\n    }\r\n    if (patchFlag === 0 && (hasRef || runtimeDirectives.length > 0)) {\r\n        patchFlag |= 32 /* NEED_PATCH */;\r\n    }\r\n    return {\r\n        props: propsExpression,\r\n        directives: runtimeDirectives,\r\n        patchFlag,\r\n        dynamicPropNames\r\n    };\r\n}\r\n// Dedupe props in an object literal.\r\n// Literal duplicated attributes would have been warned during the parse phase,\r\n// however, it's possible to encounter duplicated `onXXX` handlers with different\r\n// modifiers. We also need to merge static and dynamic class / style attributes.\r\n// - onXXX handlers / style: merge into array\r\n// - class: merge into single expression with concatenation\r\nfunction dedupeProperties(properties) {\r\n    const knownProps = {};\r\n    const deduped = [];\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const prop = properties[i];\r\n        // dynamic keys are always allowed\r\n        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {\r\n            deduped.push(prop);\r\n            continue;\r\n        }\r\n        const name = prop.key.content;\r\n        const existing = knownProps[name];\r\n        if (existing) {\r\n            if (name.startsWith('on') || name === 'style' || name === 'class') {\r\n                mergeAsArray(existing, prop);\r\n            }\r\n            // unexpected duplicate, should have emitted error during parse\r\n        }\r\n        else {\r\n            knownProps[name] = prop;\r\n            deduped.push(prop);\r\n        }\r\n    }\r\n    return deduped;\r\n}\r\nfunction mergeAsArray(existing, incoming) {\r\n    if (existing.value.type === 15 /* JS_ARRAY_EXPRESSION */) {\r\n        existing.value.elements.push(incoming.value);\r\n    }\r\n    else {\r\n        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);\r\n    }\r\n}\r\nfunction createDirectiveArgs(dir, context) {\r\n    // inject statement for resolving directive\r\n    context.helper(RESOLVE_DIRECTIVE);\r\n    context.directives.add(dir.name);\r\n    const dirArgs = [\r\n        toValidAssetId(dir.name, `directive`)\r\n    ];\r\n    const { loc } = dir;\r\n    if (dir.exp)\r\n        dirArgs.push(dir.exp);\r\n    if (dir.arg)\r\n        dirArgs.push(dir.arg);\r\n    if (Object.keys(dir.modifiers).length) {\r\n        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, createSimpleExpression(`true`, false, loc))), loc));\r\n    }\r\n    return createArrayExpression(dirArgs, dir.loc);\r\n}\r\n","references":["/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transform.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/ast.ts","/Users/apple/Desktop/vue3/vue-next/packages/shared/src/index.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/errors.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/runtimeHelpers.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/utils.ts","/Users/apple/Desktop/vue3/vue-next/packages/compiler-core/src/transforms/vSlot.ts"]}
